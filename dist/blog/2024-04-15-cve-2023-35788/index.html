<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/svg+xml" href="/sst.svg"><meta name="generator" content="Astro v5.13.7"><!-- <link rel="preload" as="image" href={src} alt="Hero" /> --><title>Root linux via an off-by-one vulnerability(CVE-2023-35788) | Shuffle Team</title><link rel="canonical" href="https://astroship.web3templates.com/blog/2024-04-15-cve-2023-35788/"><meta name="description" content="Shuffle Team combines elite human expertise with the power of AI to achieve superior security outcomes. Our security audits and tools are built on this synergy, delivering deeper insights and greater efficiency for your business."><meta name="robots" content="index, follow"><meta property="og:title" content="Shuffle Team"><meta property="og:type" content="website"><meta property="og:image" content="https://astroship.web3templates.com/sst.png"><meta property="og:url" content="https://astroship.web3templates.com/blog/2024-04-15-cve-2023-35788/"><meta property="og:image:url" content="https://astroship.web3templates.com/sst.png"><meta property="og:image:alt" content="ShuffleTeam Homepage Screenshot"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@web3templates"><meta name="twitter:creator" content="@wugedbl"><link rel="stylesheet" href="/_astro/about.CGd3VL5k.css"></head> <body> <div class="max-w-(--breakpoint-xl) mx-auto px-5">  <header class="flex flex-col lg:flex-row justify-between items-center my-5">  <div class="flex w-full lg:w-auto items-center justify-between"> <a href="/" class="text-lg"><span class="font-bold text-slate-800">Shuffle</span><span class="text-slate-500">Team</span> </a> <div class="block lg:hidden"> <button id="astronav-menu" aria-label="Toggle Menu">  <svg fill="currentColor" class="w-4 h-4 text-gray-800" width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"> <title>Toggle Menu</title> <path class="astronav-close-icon astronav-toggle hidden" fill-rule="evenodd" clip-rule="evenodd" d="M18.278 16.864a1 1 0 01-1.414 1.414l-4.829-4.828-4.828 4.828a1 1 0 01-1.414-1.414l4.828-4.829-4.828-4.828a1 1 0 011.414-1.414l4.829 4.828 4.828-4.828a1 1 0 111.414 1.414l-4.828 4.829 4.828 4.828z"></path> <path class="astronav-open-icon astronav-toggle" fill-rule="evenodd" d="M4 5h16a1 1 0 010 2H4a1 1 0 110-2zm0 6h16a1 1 0 010 2H4a1 1 0 010-2zm0 6h16a1 1 0 010 2H4a1 1 0 010-2z"></path> </svg>  </button> </div> </div> <nav class="astronav-items astronav-toggle hidden w-full lg:w-auto mt-2 lg:flex lg:mt-0">  <ul class="flex flex-col lg:flex-row lg:gap-3"> <li class="relative"> <menu class="astronav-dropdown group" aria-expanded="false"> <button class="flex items-center gap-1 w-full lg:w-auto lg:px-3 py-2 text-gray-600 hover:text-gray-900"> <span>Services</span> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-3 h-3 mt-0.5 group-open:rotate-180"> <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5"></path> </svg> </button> <div class="astronav-dropdown dropdown-toggle hidden" aria-expanded="false">  <div class="lg:absolute w-full lg:w-66 z-10 lg:left-0 origin-top-left"> <div class="px-2 py-1.5 lg:bg-white lg:rounded-md lg:shadow-lg lg:border flex flex-col gap-1"> <a href="/en/sas" class="block px-1 py-2 text-gray-600 hover:text-white hover:bg-indigo-600 rounded-md transition-colors"> Security Assessments &amp; Audits </a><a href="/en/csf" class="block px-1 py-2 text-gray-600 hover:text-white hover:bg-indigo-600 rounded-md transition-colors"> Continuous Security &amp; Fuzzing </a><a href="/en/ssa" class="block px-1 py-2 text-gray-600 hover:text-white hover:bg-indigo-600 rounded-md transition-colors"> Strategic Security Advisory </a> </div> </div>  </div> </menu> </li><li> <a href="/blog" class="flex lg:px-3 py-2 items-center text-gray-600 hover:text-gray-900"> <span> Blog</span>  </a> </li><li> <a href="/about" class="flex lg:px-3 py-2 items-center text-gray-600 hover:text-gray-900"> <span> About</span>  </a> </li><li> <a href="/contact" class="flex lg:px-3 py-2 items-center text-gray-600 hover:text-gray-900"> <span> Contact</span>  </a> </li> </ul>   </nav>  <script>(function(){const closeOnClick = false;

["DOMContentLoaded", "astro:after-swap"].forEach((event) => {
  document.addEventListener(event, addListeners);
});

// Function to clone and replace elements
function cloneAndReplace(element) {
  const clone = element.cloneNode(true);
  element.parentNode.replaceChild(clone, element);
}

function addListeners() {
  // Clean up existing listeners
  const oldMenuButton = document.getElementById("astronav-menu");
  if (oldMenuButton) {
    cloneAndReplace(oldMenuButton);
  }

  const oldDropdownMenus = document.querySelectorAll(".astronav-dropdown");
  oldDropdownMenus.forEach((menu) => {
    cloneAndReplace(menu);
  });

  // Mobile nav toggle
  const menuButton = document.getElementById("astronav-menu");
  menuButton && menuButton.addEventListener("click", toggleMobileNav);

  // Dropdown menus
  const dropdownMenus = document.querySelectorAll(".astronav-dropdown");
  dropdownMenus.forEach((menu) => {
    const button = menu.querySelector("button");
    button &&
      button.addEventListener("click", (event) =>
        toggleDropdownMenu(event, menu, dropdownMenus)
      );

    // Handle Submenu Dropdowns
    const dropDownSubmenus = menu.querySelectorAll(
      ".astronav-dropdown-submenu"
    );

    dropDownSubmenus.forEach((submenu) => {
      const submenuButton = submenu.querySelector("button");
      submenuButton &&
        submenuButton.addEventListener("click", (event) => {
          event.stopImmediatePropagation();
          toggleSubmenuDropdown(event, submenu);
        });
    });
  });

  // Clicking away from dropdown will remove the dropdown class
  document.addEventListener("click", closeAllDropdowns);

  if (closeOnClick) {
    handleCloseOnClick();
  }
}

function toggleMobileNav() {
  [...document.querySelectorAll(".astronav-toggle")].forEach((el) => {
    el.classList.toggle("hidden");
  });
}

function toggleDropdownMenu(event, menu, dropdownMenus) {
  toggleMenu(menu);

  // Close one dropdown when selecting another
  Array.from(dropdownMenus)
    .filter((el) => el !== menu && !menu.contains(el))
    .forEach(closeMenu);

  event.stopPropagation();
}

function toggleSubmenuDropdown(event, submenu) {
  event.stopPropagation();
  toggleMenu(submenu);

  // Close sibling submenus at the same nesting level
  const siblingSubmenus = submenu
    .closest(".astronav-dropdown")
    .querySelectorAll(".astronav-dropdown-submenu");
  Array.from(siblingSubmenus)
    .filter((el) => el !== submenu && !submenu.contains(el))
    .forEach(closeMenu);
}

function closeAllDropdowns(event) {
  const dropdownMenus = document.querySelectorAll(".dropdown-toggle");
  const dropdownParent = document.querySelectorAll(
    ".astronav-dropdown, .astronav-dropdown-submenu"
  );
  const isButtonInsideDropdown = [
    ...document.querySelectorAll(
      `.astronav-dropdown button, .astronav-dropdown label, .astronav-dropdown input,
	  .astronav-dropdown-submenu button, .astronav-dropdown-submenu label, .astronav-dropdown-submenu input,
	  #astronav-menu`
    ),
  ].some((button) => button.contains(event.target));
  if (!isButtonInsideDropdown) {
    dropdownMenus.forEach((d) => {
      // console.log("I ran", d);
      // if (!d.contains(event.target)) {
      d.classList.remove("open");
      d.removeAttribute("open");
      d.classList.add("hidden");
      // }
    });
    dropdownParent.forEach((d) => {
      d.classList.remove("open");
      d.removeAttribute("open");
      d.setAttribute("aria-expanded", "false");
    });
  }
}

function toggleMenu(menu) {
  menu.classList.toggle("open");
  const expanded = menu.getAttribute("aria-expanded") === "true";
  menu.setAttribute("aria-expanded", expanded ? "false" : "true");
  menu.hasAttribute("open")
    ? menu.removeAttribute("open")
    : menu.setAttribute("open", "");

  const dropdownToggle = menu.querySelector(".dropdown-toggle");
  const dropdownExpanded = dropdownToggle.getAttribute("aria-expanded");
  dropdownToggle.classList.toggle("hidden");
  dropdownToggle.setAttribute(
    "aria-expanded",
    dropdownExpanded === "true" ? "false" : "true"
  );
}

function closeMenu(menu) {
  // console.log("closing", menu);
  menu.classList.remove("open");
  menu.removeAttribute("open");
  menu.setAttribute("aria-expanded", "false");
  const dropdownToggles = menu.querySelectorAll(".dropdown-toggle");
  dropdownToggles.forEach((toggle) => {
    toggle.classList.add("hidden");
    toggle.setAttribute("aria-expanded", "false");
  });
}

function handleCloseOnClick() {
  const navMenuItems = document.querySelector(".astronav-items");
  const navToggle = document.getElementById("astronav-menu");
  const navLink = navMenuItems && navMenuItems.querySelectorAll("a");

  const MenuIcons = navToggle.querySelectorAll(".astronav-toggle");

  navLink &&
    navLink.forEach((item) => {
      item.addEventListener("click", () => {
        navMenuItems?.classList.add("hidden");
        MenuIcons.forEach((el) => {
          el.classList.toggle("hidden");
        });
      });
    });
}
})();</script> <div slot="actions"> <!-- <a 
  href={targetPath} 
  class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
>
  {buttonText}
</a> --><!-- 如果您更喜欢两个并排的链接，而不是单个切换按钮，可以使用下面的代码 --> </div> <!-- <div>
      <div class="hidden lg:flex items-center gap-4">
        <a href="#">Log in</a>
        <Link href="#" size="md">Sign up</Link>
      </div>
    </div> --> </header>  </div>  <div class="max-w-(--breakpoint-xl) mx-auto px-5">  <div class="mx-auto max-w-3xl mt-14"> <span class="text-blue-400 uppercase tracking-wider text-sm font-medium"> Exploit </span> <h1 class="text-4xl lg:text-5xl font-bold lg:tracking-tight mt-1 lg:leading-tight"> Root linux via an off-by-one vulnerability(CVE-2023-35788) </h1> <div class="flex gap-2 mt-3 items-center flex-wrap md:flex-nowrap"> <span class="text-gray-400"> shuffle team </span> <span class="text-gray-400">•</span> <time class="text-gray-400" datetime="2024-04-15T03:39:00.000Z"> Mon Apr 15 2024 </time> <span class="text-gray-400 hidden md:block">•</span> <div class="w-full md:w-auto flex flex-wrap gap-3"> <span class="text-sm text-gray-500">#root</span><span class="text-sm text-gray-500">#linux kernel</span><span class="text-sm text-gray-500">#off-by-one</span> </div> </div> </div> <div class="mx-auto prose prose-lg mt-6 max-w-3xl"> <h2 id="0x00-introduction">0x00 Introduction</h2>
<p>The vulnerability is an off-by-one flaw located within the Linux network scheduler subsystem (NET_SCHED). It allows bypassing all protective measures (though a new namespace needs to be created) and enables privilege escalation on Linux systems.</p>
<p>NET_SCHED in Linux is the Network Scheduler subsystem, which is responsible for traffic scheduling and management in the network stack. It provides a range of scheduling algorithms and queue management mechanisms, including priority queuing, token bucket scheduling, and random early detection, enabling users to flexibly control and optimize network traffic as needed.</p>
<p>This vulnerability is not a new one. It was already patched in Linux 6.4-rc5 (June 2023) by us. However, due to its interesting nature, involving out-of-bounds access within a structure, it does not cause a kernel crash when triggered. Moreover, its exploit stability is quite high. So, I have decided to outline the exploitation approach for this vulnerability.</p>
<p>Since NET_SCHED is a well-known module that has experienced several vulnerabilities (you can check KCTF). This article will focus solely on the vulnerability itself.</p>
<p><img alt="meme1" loading="lazy" decoding="async" fetchpriority="auto" width="107" height="107" src="/_astro/meme1.ia0-JN6z_Z1iseDK.webp" ></p>
<h2 id="0x01-vulnerability-analysis">0x01 Vulnerability Analysis</h2>
<p>The vulnerability occurs in the Flower classifier of NET_SCHED.</p>
<p>The core function containing the vulnerability is <code>fl_set_geneve_opt()</code>. Below is the code snippet provided:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">static</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> fl_set_geneve_opt</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">const</span><span style="color:#F97583"> struct</span><span style="color:#E1E4E8"> nlattr </span><span style="color:#F97583">*</span><span style="color:#FFAB70">nla</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> fl_flow_key </span><span style="color:#F97583">*</span><span style="color:#FFAB70">key</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">			     int</span><span style="color:#FFAB70"> depth</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> option_len</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">			     struct</span><span style="color:#E1E4E8"> netlink_ext_ack </span><span style="color:#F97583">*</span><span style="color:#FFAB70">extack</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> nlattr </span><span style="color:#F97583">*</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> nlattr </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">class </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">type </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">data </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> geneve_opt </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">opt;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> err, data_len </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (option_len </span><span style="color:#F97583">></span><span style="color:#F97583"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt))</span></span>
<span class="line"><span style="color:#E1E4E8">		data_len </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> option_len </span><span style="color:#F97583">-</span><span style="color:#F97583"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">	opt </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">key->enc_opts.data[key->enc_opts.len];	</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#B392F0">	memset</span><span style="color:#E1E4E8">(opt, </span><span style="color:#F97583">0x</span><span style="color:#79B8FF">ff</span><span style="color:#E1E4E8">, option_len);</span></span>
<span class="line"><span style="color:#E1E4E8">	opt->length </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> data_len </span><span style="color:#F97583">/</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	opt->r1 </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	opt->r2 </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	opt->r3 </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">	/* If no mask has been prodived we assume an exact match. */</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">depth)</span></span>
<span class="line"><span style="color:#F97583">		return</span><span style="color:#F97583"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt) </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> data_len;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">nla_type</span><span style="color:#E1E4E8">(nla) </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> TCA_FLOWER_KEY_ENC_OPTS_GENEVE) {</span></span>
<span class="line"><span style="color:#B392F0">		NL_SET_ERR_MSG</span><span style="color:#E1E4E8">(extack, </span><span style="color:#9ECBFF">"Non-geneve option type for mask"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">		return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">EINVAL;</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">	err </span><span style="color:#F97583">=</span><span style="color:#B392F0"> nla_parse_nested_deprecated</span><span style="color:#E1E4E8">(tb,</span></span>
<span class="line"><span style="color:#E1E4E8">					  TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX,</span></span>
<span class="line"><span style="color:#E1E4E8">					  nla, geneve_opt_policy, extack);					</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (err </span><span style="color:#F97583">&#x3C;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">		return</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">	/* We are not allowed to omit any of CLASS, TYPE or DATA</span></span>
<span class="line"><span style="color:#6A737D">	 * fields from the key.</span></span>
<span class="line"><span style="color:#6A737D">	 */</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">option_len </span><span style="color:#F97583">&#x26;&#x26;</span></span>
<span class="line"><span style="color:#E1E4E8">	    (</span><span style="color:#F97583">!</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS] </span><span style="color:#F97583">||</span></span>
<span class="line"><span style="color:#F97583">	     !</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE] </span><span style="color:#F97583">||</span></span>
<span class="line"><span style="color:#F97583">	     !</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA])) {</span></span>
<span class="line"><span style="color:#B392F0">		NL_SET_ERR_MSG</span><span style="color:#E1E4E8">(extack, </span><span style="color:#9ECBFF">"Missing tunnel key geneve option class, type or data"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">		return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">EINVAL;</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">	/* Omitting any of CLASS, TYPE or DATA fields is allowed</span></span>
<span class="line"><span style="color:#6A737D">	 * for the mask.</span></span>
<span class="line"><span style="color:#6A737D">	 */</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA]) {</span></span>
<span class="line"><span style="color:#F97583">		int</span><span style="color:#E1E4E8"> new_len </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> key->enc_opts.len;								</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">		data </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA];</span></span>
<span class="line"><span style="color:#E1E4E8">		data_len </span><span style="color:#F97583">=</span><span style="color:#B392F0"> nla_len</span><span style="color:#E1E4E8">(data);</span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (data_len </span><span style="color:#F97583">&#x3C;</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">) {												</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#B392F0">			NL_SET_ERR_MSG</span><span style="color:#E1E4E8">(extack, </span><span style="color:#9ECBFF">"Tunnel key geneve option data is less than 4 bytes long"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">			return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">ERANGE;</span></span>
<span class="line"><span style="color:#E1E4E8">		}</span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (data_len </span><span style="color:#F97583">%</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">) {												</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#B392F0">			NL_SET_ERR_MSG</span><span style="color:#E1E4E8">(extack, </span><span style="color:#9ECBFF">"Tunnel key geneve option data is not a multiple of 4 bytes long"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">			return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">ERANGE;</span></span>
<span class="line"><span style="color:#E1E4E8">		}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">		new_len </span><span style="color:#F97583">+=</span><span style="color:#F97583"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt) </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> data_len;</span></span>
<span class="line"><span style="color:#B392F0">		BUILD_BUG_ON</span><span style="color:#E1E4E8">(FLOW_DIS_TUN_OPTS_MAX </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> IP_TUNNEL_OPTS_MAX);</span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (new_len </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> FLOW_DIS_TUN_OPTS_MAX) {							</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">6</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#B392F0">			NL_SET_ERR_MSG</span><span style="color:#E1E4E8">(extack, </span><span style="color:#9ECBFF">"Tunnel options exceeds max size"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">			return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">ERANGE;</span></span>
<span class="line"><span style="color:#E1E4E8">		}</span></span>
<span class="line"><span style="color:#E1E4E8">		opt->length </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> data_len </span><span style="color:#F97583">/</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#B392F0">		memcpy</span><span style="color:#E1E4E8">(opt->opt_data, </span><span style="color:#B392F0">nla_data</span><span style="color:#E1E4E8">(data), data_len);				</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">7</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS]) {</span></span>
<span class="line"><span style="color:#E1E4E8">		class </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS];</span></span>
<span class="line"><span style="color:#E1E4E8">		opt->opt_class </span><span style="color:#F97583">=</span><span style="color:#B392F0"> nla_get_be16</span><span style="color:#E1E4E8">(class);</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE]) {</span></span>
<span class="line"><span style="color:#E1E4E8">		type </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE];</span></span>
<span class="line"><span style="color:#E1E4E8">		opt->type </span><span style="color:#F97583">=</span><span style="color:#B392F0"> nla_get_u8</span><span style="color:#E1E4E8">(type);</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	return</span><span style="color:#F97583"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt) </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> data_len;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>At position [1], the function <code>fl_set_geneve_opt()</code> directly uses <code>key->enc_opts.len</code> as an array parameter, retrieving the <code>opt</code> structure from the <code>key->enc_opts.data</code> array, and setting the data of length <code>option_len</code> to 0xff. Additionally, some fields of the <code>opt</code> structure are initialized. Upon examining the <code>struct geneve_opt</code> structure of <code>opt</code>, it is evident that initializing the <code>geneve_opt</code> structure requires exactly 4 bytes.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt {</span></span>
<span class="line"><span style="color:#E1E4E8">	__be16	opt_class;</span></span>
<span class="line"><span style="color:#E1E4E8">	u8	type;</span></span>
<span class="line"><span style="color:#F97583">#ifdef</span><span style="color:#B392F0"> __LITTLE_ENDIAN_BITFIELD</span></span>
<span class="line"><span style="color:#E1E4E8">	u8	length:</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	u8	r3:</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	u8	r2:</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	u8	r1:</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">#else</span></span>
<span class="line"><span style="color:#E1E4E8">	u8	r1:</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	u8	r2:</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	u8	r3:</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	u8	length:</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">#endif</span></span>
<span class="line"><span style="color:#E1E4E8">	u8	opt_data</span><span style="color:#F97583">[]</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span></code></pre>
<p>Continuing to position [2], the function parses the user-provided packet data into the <code>tb</code> array. Additionally, due to the set <code>geneve_opt_policy</code>, if data of type TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA is passed in (parsed at position [3]), it must not exceed 128 bytes.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">static</span><span style="color:#F97583"> const</span><span style="color:#F97583"> struct</span><span style="color:#E1E4E8"> nla_policy</span></span>
<span class="line"><span style="color:#FFAB70">geneve_opt_policy</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">	[TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS]      </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> { .type </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> NLA_U16 },</span></span>
<span class="line"><span style="color:#E1E4E8">	[TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE]       </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> { .type </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> NLA_U8 },</span></span>
<span class="line"><span style="color:#E1E4E8">	[TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA]       </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> { .type </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> NLA_BINARY,</span></span>
<span class="line"><span style="color:#E1E4E8">						       .len </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 128</span><span style="color:#E1E4E8"> },</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span></code></pre>
<p>Here we arrive at position [3]. We can observe that the variable <code>key->enc_opts.len</code>, used for the array, is assigned to <code>new_len</code>. Since <code>tb</code> is user-supplied data, positions [4] and [5] are used to ensure that the data we pass in is divisible by 4 and greater than the packet header, i.e., the <code>struct geneve_opt</code> structure. Then, at position [6], the code checks whether the length of <code>key->enc_opts.len</code> plus the length of our newly passed packet data is less than 255, which is the size of the <code>key->enc_opts.data</code> array. After this series of validations, the data is finally copied to the <code>opt_data</code> field of <code>geneve_opt</code> using <code>memcpy</code> at position [7]. In the end, <code>fl_set_geneve_opt</code> will return the length of the new packet header plus the length of the data.</p>
<p>Now, let’s see how <code>key->enc_opts.len</code> is assigned.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">static</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> fl_set_enc_opt</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> nlattr </span><span style="color:#F97583">**</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> fl_flow_key </span><span style="color:#F97583">*</span><span style="color:#FFAB70">key</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">			  struct</span><span style="color:#E1E4E8"> fl_flow_key </span><span style="color:#F97583">*</span><span style="color:#FFAB70">mask</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">			  struct</span><span style="color:#E1E4E8"> netlink_ext_ack </span><span style="color:#F97583">*</span><span style="color:#FFAB70">extack</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#E1E4E8">...</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPTS_MASK]) {</span></span>
<span class="line"><span style="color:#E1E4E8">		err </span><span style="color:#F97583">=</span><span style="color:#B392F0"> nla_validate_nested_deprecated</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPTS_MASK],</span></span>
<span class="line"><span style="color:#E1E4E8">						     TCA_FLOWER_KEY_ENC_OPTS_MAX,</span></span>
<span class="line"><span style="color:#E1E4E8">						     enc_opts_policy, extack);</span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (err)</span></span>
<span class="line"><span style="color:#F97583">			return</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">		nla_opt_msk </span><span style="color:#F97583">=</span><span style="color:#B392F0"> nla_data</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPTS_MASK]);</span></span>
<span class="line"><span style="color:#E1E4E8">		msk_depth </span><span style="color:#F97583">=</span><span style="color:#B392F0"> nla_len</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPTS_MASK]);</span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#B392F0">nla_ok</span><span style="color:#E1E4E8">(nla_opt_msk, msk_depth)) {</span></span>
<span class="line"><span style="color:#B392F0">			NL_SET_ERR_MSG</span><span style="color:#E1E4E8">(extack, </span><span style="color:#9ECBFF">"Invalid nested attribute for masks"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">			return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">EINVAL;</span></span>
<span class="line"><span style="color:#E1E4E8">		}</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">	nla_for_each_attr</span><span style="color:#E1E4E8">(nla_opt_key, nla_enc_key,</span></span>
<span class="line"><span style="color:#B392F0">			  nla_len</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPTS]), key_depth) {</span></span>
<span class="line"><span style="color:#F97583">		switch</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">nla_type</span><span style="color:#E1E4E8">(nla_opt_key)) {</span></span>
<span class="line"><span style="color:#F97583">		case</span><span style="color:#E1E4E8"> TCA_FLOWER_KEY_ENC_OPTS_GENEVE:</span></span>
<span class="line"><span style="color:#F97583">			if</span><span style="color:#E1E4E8"> (key</span><span style="color:#F97583">-></span><span style="color:#E1E4E8">enc_opts.dst_opt_type </span><span style="color:#F97583">&#x26;&#x26;</span></span>
<span class="line"><span style="color:#E1E4E8">			    key</span><span style="color:#F97583">-></span><span style="color:#E1E4E8">enc_opts.dst_opt_type </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> TUNNEL_GENEVE_OPT) {</span></span>
<span class="line"><span style="color:#B392F0">				NL_SET_ERR_MSG</span><span style="color:#E1E4E8">(extack, </span><span style="color:#9ECBFF">"Duplicate type for geneve options"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">				return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">EINVAL;</span></span>
<span class="line"><span style="color:#E1E4E8">			}</span></span>
<span class="line"><span style="color:#E1E4E8">			option_len </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">			key->enc_opts.dst_opt_type </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> TUNNEL_GENEVE_OPT;</span></span>
<span class="line"><span style="color:#E1E4E8">			option_len </span><span style="color:#F97583">=</span><span style="color:#B392F0"> fl_set_geneve_opt</span><span style="color:#E1E4E8">(nla_opt_key, key,	</span></span>
<span class="line"><span style="color:#E1E4E8">						       key_depth, option_len,</span></span>
<span class="line"><span style="color:#E1E4E8">						       extack);</span></span>
<span class="line"><span style="color:#F97583">			if</span><span style="color:#E1E4E8"> (option_len </span><span style="color:#F97583">&#x3C;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">				return</span><span style="color:#E1E4E8"> option_len;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">			key->enc_opts.len </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> option_len;						</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">8</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#6A737D">			/* At the same time we need to parse through the mask</span></span>
<span class="line"><span style="color:#6A737D">			 * in order to verify exact and mask attribute lengths.</span></span>
<span class="line"><span style="color:#6A737D">			 */</span></span>
<span class="line"><span style="color:#E1E4E8">			mask->enc_opts.dst_opt_type </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> TUNNEL_GENEVE_OPT;</span></span>
<span class="line"><span style="color:#E1E4E8">			option_len </span><span style="color:#F97583">=</span><span style="color:#B392F0"> fl_set_geneve_opt</span><span style="color:#E1E4E8">(nla_opt_msk, mask,</span></span>
<span class="line"><span style="color:#E1E4E8">						       msk_depth, option_len,</span></span>
<span class="line"><span style="color:#E1E4E8">						       extack);</span></span>
<span class="line"><span style="color:#F97583">			if</span><span style="color:#E1E4E8"> (option_len </span><span style="color:#F97583">&#x3C;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">				return</span><span style="color:#E1E4E8"> option_len;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">			mask->enc_opts.len </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> option_len;						</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">9</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#F97583">			if</span><span style="color:#E1E4E8"> (key</span><span style="color:#F97583">-></span><span style="color:#E1E4E8">enc_opts.len </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> mask</span><span style="color:#F97583">-></span><span style="color:#E1E4E8">enc_opts.len) {			</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#B392F0">				NL_SET_ERR_MSG</span><span style="color:#E1E4E8">(extack, </span><span style="color:#9ECBFF">"Key and mask miss aligned"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">				return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">EINVAL;</span></span>
<span class="line"><span style="color:#E1E4E8">			}</span></span>
<span class="line"><span style="color:#F97583">			break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">...</span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">msk_depth)</span></span>
<span class="line"><span style="color:#F97583">			continue</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#B392F0">nla_ok</span><span style="color:#E1E4E8">(nla_opt_msk, msk_depth)) {</span></span>
<span class="line"><span style="color:#B392F0">			NL_SET_ERR_MSG</span><span style="color:#E1E4E8">(extack, </span><span style="color:#9ECBFF">"A mask attribute is invalid"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">			return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">EINVAL;</span></span>
<span class="line"><span style="color:#E1E4E8">		}</span></span>
<span class="line"><span style="color:#E1E4E8">		nla_opt_msk </span><span style="color:#F97583">=</span><span style="color:#B392F0"> nla_next</span><span style="color:#E1E4E8">(nla_opt_msk, </span><span style="color:#F97583">&#x26;</span><span style="color:#FFAB70">msk_depth</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>We observe that the higher-level function of <code>fl_set_geneve_opt</code> is <code>fl_set_enc_opt</code>. <code>fl_set_enc_opt</code> is responsible for determining the possibility of passing in multiple data packets. Therefore, it iterates internally to parse each packet of <code>TCA_FLOWER_KEY_ENC_OPTS_GENEVE</code> type. These packets are categorized into key and mask types, with the requirement that there must be a key before a mask, and the lengths of the key and mask must be equal (checked at position [10]). The <code>enc_opts.len</code> we are concerned with represents the cumulative length of the data packets already passed in.</p>
<p>So far, it appears there isn’t an issue because even if there’s an array overflow at position [1], the lengths of <code>key->enc_opts.len</code> and the subsequent data packets will be checked, and the process will fail due to failed validation.</p>
<p><img alt="meme2" loading="lazy" decoding="async" fetchpriority="auto" width="608" height="448" src="/_astro/meme2.DPBVb5Sr_JkcPc.webp" ></p>
<p>However, let’s take a closer look at the structure containing this potentially overflowing array.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> flow_dissector_key_enc_opts {</span></span>
<span class="line"><span style="color:#E1E4E8">	u8 </span><span style="color:#FFAB70">data</span><span style="color:#E1E4E8">[FLOW_DIS_TUN_OPTS_MAX];</span><span style="color:#6A737D">	/* Using IP_TUNNEL_OPTS_MAX is desired</span></span>
<span class="line"><span style="color:#6A737D">					 * here but seems difficult to #include</span></span>
<span class="line"><span style="color:#6A737D">					 */</span></span>
<span class="line"><span style="color:#E1E4E8">	u8 len;</span></span>
<span class="line"><span style="color:#E1E4E8">	__be16 dst_opt_type;</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span></code></pre>
<p>The <code>data</code> array is of length 255, followed immediately by <code>len</code>, which is of type <code>u8</code>, occupying just one byte with a maximum value of 255. However, the issue arises here. Suppose we pass in two or more data packets with a cumulative total size of 252. Due to the initialization of a 4-byte <code>struct geneve_opt</code> header directly at position [1], an off-by-one error occurs. Fortunately, this off-by-one error precisely overwrites the <code>len</code> field of the <code>flow_dissector_key_enc_opts</code> structure. Thus, relying on this off-by-one error, we can access position <code>key->enc_opts.data[252]</code>. However, <code>key->enc_opts.len</code> is overwritten with a value less than 128 (calculated as 4 + package length/4 + package length). This means <code>key->enc_opts.len = opt->length = data_len / 4</code>. Consequently, we can bypass the checks at positions [4], [5], and [6], resulting in an out-of-bounds write of up to 128 bytes.</p>
<h2 id="0x02-exploit">0x02 Exploit</h2>
<p>Now that we have a maximum of 128 bytes for the out-of-bounds write, since the overflow occurs in a nested structure, let’s first trace the function call chain of <code>fl_set_geneve_opt</code>.</p>
<p><img alt="1" loading="lazy" decoding="async" fetchpriority="auto" width="589" height="300" src="/_astro/1.5N3YBGn6_pe3H6.webp" ></p>
<p>As shown in the above diagram, the top-level functions are <code>tc_new_tfilter</code> and <code>tc_ctl_chain</code>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">static</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8"> __init </span><span style="color:#B392F0">tc_filter_init</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">void</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">	tc_filter_wq </span><span style="color:#F97583">=</span><span style="color:#B392F0"> alloc_ordered_workqueue</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"tc_filter_workqueue"</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">tc_filter_wq)</span></span>
<span class="line"><span style="color:#F97583">		return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">ENOMEM;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">	err </span><span style="color:#F97583">=</span><span style="color:#B392F0"> register_pernet_subsys</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">tcf_net_ops);</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (err)</span></span>
<span class="line"><span style="color:#F97583">		goto</span><span style="color:#E1E4E8"> err_register_pernet_subsys;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">	rtnl_register</span><span style="color:#E1E4E8">(PF_UNSPEC, RTM_NEWTFILTER, tc_new_tfilter, </span><span style="color:#79B8FF">NULL</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">		      RTNL_FLAG_DOIT_UNLOCKED);</span></span>
<span class="line"><span style="color:#B392F0">	rtnl_register</span><span style="color:#E1E4E8">(PF_UNSPEC, RTM_DELTFILTER, tc_del_tfilter, </span><span style="color:#79B8FF">NULL</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">		      RTNL_FLAG_DOIT_UNLOCKED);</span></span>
<span class="line"><span style="color:#B392F0">	rtnl_register</span><span style="color:#E1E4E8">(PF_UNSPEC, RTM_GETTFILTER, tc_get_tfilter,</span></span>
<span class="line"><span style="color:#E1E4E8">		      tc_dump_tfilter, RTNL_FLAG_DOIT_UNLOCKED);</span></span>
<span class="line"><span style="color:#B392F0">	rtnl_register</span><span style="color:#E1E4E8">(PF_UNSPEC, RTM_NEWCHAIN, tc_ctl_chain, </span><span style="color:#79B8FF">NULL</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">	rtnl_register</span><span style="color:#E1E4E8">(PF_UNSPEC, RTM_DELCHAIN, tc_ctl_chain, </span><span style="color:#79B8FF">NULL</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">	rtnl_register</span><span style="color:#E1E4E8">(PF_UNSPEC, RTM_GETCHAIN, tc_ctl_chain,</span></span>
<span class="line"><span style="color:#E1E4E8">		      tc_dump_chain, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	return</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">err_register_pernet_subsys:</span></span>
<span class="line"><span style="color:#B392F0">	destroy_workqueue</span><span style="color:#E1E4E8">(tc_filter_wq);</span></span>
<span class="line"><span style="color:#F97583">	return</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Here, <code>tc_new_tfilter</code> and <code>tc_ctl_chain</code> are respectively called when the user passes in types such as RTM_NEWTFILTER and RTM_NEWCHAIN via Netlink.</p>
<p>The intermediate layer’s virtual functions are located in <code>cls_fl_ops</code>. Positions [11] and [12] are where we can trigger the vulnerable function.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">static</span><span style="color:#F97583"> struct</span><span style="color:#E1E4E8"> tcf_proto_ops cls_fl_ops __read_mostly </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">	.kind		</span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> "flower"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">	.classify	</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_classify,</span></span>
<span class="line"><span style="color:#E1E4E8">	.init		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_init,</span></span>
<span class="line"><span style="color:#E1E4E8">	.destroy	</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_destroy,</span></span>
<span class="line"><span style="color:#E1E4E8">	.get		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_get,</span></span>
<span class="line"><span style="color:#E1E4E8">	.put		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_put,</span></span>
<span class="line"><span style="color:#E1E4E8">	.change		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_change,				</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">11</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">	.delete		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_delete,</span></span>
<span class="line"><span style="color:#E1E4E8">	.delete_empty	</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_delete_empty,</span></span>
<span class="line"><span style="color:#E1E4E8">	.walk		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_walk,</span></span>
<span class="line"><span style="color:#E1E4E8">	.reoffload	</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_reoffload,</span></span>
<span class="line"><span style="color:#E1E4E8">	.hw_add		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_hw_add,</span></span>
<span class="line"><span style="color:#E1E4E8">	.hw_del		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_hw_del,</span></span>
<span class="line"><span style="color:#E1E4E8">	.dump		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_dump,</span></span>
<span class="line"><span style="color:#E1E4E8">	.terse_dump	</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_terse_dump,</span></span>
<span class="line"><span style="color:#E1E4E8">	.bind_class	</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_bind_class,</span></span>
<span class="line"><span style="color:#E1E4E8">	.tmplt_create	</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_tmplt_create,		</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">12</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">	.tmplt_destroy	</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_tmplt_destroy,</span></span>
<span class="line"><span style="color:#E1E4E8">	.tmplt_dump	</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_tmplt_dump,</span></span>
<span class="line"><span style="color:#E1E4E8">	.owner		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> THIS_MODULE,</span></span>
<span class="line"><span style="color:#E1E4E8">	.flags		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> TCF_PROTO_OPS_DOIT_UNLOCKED,</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span></code></pre>
<p>Once we’ve identified the call chain, we can follow these two chains to find the objects we can overflow. The two directly overflowable objects are as follows:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> fl_flow_tmplt {</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> fl_flow_key dummy_key;      </span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">13</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> fl_flow_key mask;		   </span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">14</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> flow_dissector dissector;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> tcf_chain </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">chain;</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> cls_fl_filter {</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> fl_flow_mask </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">mask;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> rhash_head ht_node;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> fl_flow_key mkey;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> tcf_exts exts;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> tcf_result res;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> fl_flow_key key;				 </span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">15</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> list_head list;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> list_head hw_list;</span></span>
<span class="line"><span style="color:#E1E4E8">	u32 handle;</span></span>
<span class="line"><span style="color:#E1E4E8">	u32 flags;</span></span>
<span class="line"><span style="color:#E1E4E8">	u32 in_hw_count;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> rcu_work rwork;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> net_device </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">hw_dev;</span></span>
<span class="line"><span style="color:#6A737D">	/* Flower classifier is unlocked, which means that its reference counter</span></span>
<span class="line"><span style="color:#6A737D">	 * can be changed concurrently without any kind of external</span></span>
<span class="line"><span style="color:#6A737D">	 * synchronization. Use atomic reference counter to be concurrency-safe.</span></span>
<span class="line"><span style="color:#6A737D">	 */</span></span>
<span class="line"><span style="color:#79B8FF">	refcount_t</span><span style="color:#E1E4E8"> refcnt;</span></span>
<span class="line"><span style="color:#F97583">	bool</span><span style="color:#E1E4E8"> deleted;</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span></code></pre>
<p>We focus on the <code>fl_flow_tmplt</code> structure. Since we can overflow 128 bytes and overwrite the object pointer of <code>chain</code>, modifying <code>chain</code> allows us to perform interesting fabrications when <code>fl_flow_tmplt</code> calls this object. Additionally, we find that the <code>cls_fl_ops</code> virtual functions include a <code>fl_tmplt_destroy</code> function.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">static</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> fl_tmplt_destroy</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">void</span><span style="color:#F97583"> *</span><span style="color:#FFAB70">tmplt_priv</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> fl_flow_tmplt </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">tmplt </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tmplt_priv;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">	fl_hw_destroy_tmplt</span><span style="color:#E1E4E8">(tmplt->chain, tmplt);							</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">16</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#B392F0">	kfree</span><span style="color:#E1E4E8">(tmplt);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">static</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> fl_hw_destroy_tmplt</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> tcf_chain </span><span style="color:#F97583">*</span><span style="color:#FFAB70">chain</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">				struct</span><span style="color:#E1E4E8"> fl_flow_tmplt </span><span style="color:#F97583">*</span><span style="color:#FFAB70">tmplt</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> flow_cls_offload cls_flower </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> {};</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> tcf_block </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">block </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> chain->block;								</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">17</span><span style="color:#E1E4E8">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">	cls_flower.common.chain_index </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> chain->index;</span></span>
<span class="line"><span style="color:#E1E4E8">	cls_flower.command </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> FLOW_CLS_TMPLT_DESTROY;</span></span>
<span class="line"><span style="color:#E1E4E8">	cls_flower.cookie </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">unsigned</span><span style="color:#F97583"> long</span><span style="color:#E1E4E8">) tmplt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">	tc_setup_cb_call</span><span style="color:#E1E4E8">(block, TC_SETUP_CLSFLOWER, </span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">cls_flower, </span><span style="color:#79B8FF">false</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">int</span><span style="color:#B392F0"> tc_setup_cb_call</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> tcf_block </span><span style="color:#F97583">*</span><span style="color:#FFAB70">block</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">enum</span><span style="color:#E1E4E8"> tc_setup_type </span><span style="color:#FFAB70">type</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">		     void</span><span style="color:#F97583"> *</span><span style="color:#FFAB70">type_data</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">bool</span><span style="color:#FFAB70"> err_stop</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">bool</span><span style="color:#FFAB70"> rtnl_held</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">	bool</span><span style="color:#E1E4E8"> take_rtnl </span><span style="color:#F97583">=</span><span style="color:#B392F0"> READ_ONCE</span><span style="color:#E1E4E8">(block->lockeddevcnt) </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">rtnl_held;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> ok_count;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">retry:</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (take_rtnl)</span></span>
<span class="line"><span style="color:#B392F0">		rtnl_lock</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">	down_read</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">block->cb_lock);</span></span>
<span class="line"><span style="color:#6A737D">	/* Need to obtain rtnl lock if block is bound to devs that require it.</span></span>
<span class="line"><span style="color:#6A737D">	 * In block bind code cb_lock is obtained while holding rtnl, so we must</span></span>
<span class="line"><span style="color:#6A737D">	 * obtain the locks in same order here.</span></span>
<span class="line"><span style="color:#6A737D">	 */</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">rtnl_held </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">take_rtnl </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> block->lockeddevcnt) {</span></span>
<span class="line"><span style="color:#B392F0">		up_read</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">block->cb_lock);</span></span>
<span class="line"><span style="color:#E1E4E8">		take_rtnl </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">		goto</span><span style="color:#E1E4E8"> retry;</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">	ok_count </span><span style="color:#F97583">=</span><span style="color:#B392F0"> __tc_setup_cb_call</span><span style="color:#E1E4E8">(block, type, type_data, err_stop);	</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">18</span><span style="color:#E1E4E8">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">	up_read</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">block->cb_lock);</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (take_rtnl)</span></span>
<span class="line"><span style="color:#B392F0">		rtnl_unlock</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">	return</span><span style="color:#E1E4E8"> ok_count;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">static</span><span style="color:#F97583"> int</span></span>
<span class="line"><span style="color:#B392F0">__tc_setup_cb_call</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> tcf_block </span><span style="color:#F97583">*</span><span style="color:#FFAB70">block</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">enum</span><span style="color:#E1E4E8"> tc_setup_type </span><span style="color:#FFAB70">type</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">		   void</span><span style="color:#F97583"> *</span><span style="color:#FFAB70">type_data</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">bool</span><span style="color:#FFAB70"> err_stop</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> flow_block_cb </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">block_cb;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> ok_count </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">	list_for_each_entry</span><span style="color:#E1E4E8">(block_cb, </span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">block->flow_block.cb_list, list) {</span></span>
<span class="line"><span style="color:#E1E4E8">		err </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> block_cb-></span><span style="color:#B392F0">cb</span><span style="color:#E1E4E8">(type, type_data, block_cb->cb_priv);			</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">19</span><span style="color:#E1E4E8">] </span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#F97583">			if</span><span style="color:#E1E4E8"> (err_stop)</span></span>
<span class="line"><span style="color:#F97583">				return</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"><span style="color:#E1E4E8">		} </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">			ok_count</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">		}</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"><span style="color:#F97583">	return</span><span style="color:#E1E4E8"> ok_count;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>By tracing the <code>fl_tmplt_destroy</code> function, we can observe that at position [16], we can control <code>tmplt->chain</code>. Therefore, at positions [17] and [18], we can control <code>block</code>. At position [19], we have a suitable pointer, enabling control flow hijacking.</p>
<p>At this point, our strategy is clear. We need to leak a controllable heap address, while simultaneously bypassing KASLR to obtain usable function pointers. Both of these tasks require out-of-bounds reads.</p>
<h3 id="transforming-the-off-by-one-vulnerability-into-an-out-of-bounds-read-vulnerability">Transforming the off-by-one vulnerability into an out-of-bounds read vulnerability</h3>
<p>We need out-of-bounds reads, and conveniently, from <code>cls_fl_ops</code>, we can see two functions that transfer data from the kernel to user space: <code>fl_dump</code> and <code>fl_tmplt_dump</code>. These correspond to the two vulnerable functions we just discussed.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">static</span><span style="color:#F97583"> struct</span><span style="color:#E1E4E8"> tcf_proto_ops cls_fl_ops __read_mostly </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">	.kind		</span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> "flower"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">...</span></span>
<span class="line"><span style="color:#E1E4E8">	.change		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_change,				</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">11</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">	.delete		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_delete,</span></span>
<span class="line"><span style="color:#E1E4E8">...</span></span>
<span class="line"><span style="color:#E1E4E8">	.dump		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_dump,</span></span>
<span class="line"><span style="color:#E1E4E8">	.terse_dump	</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_terse_dump,</span></span>
<span class="line"><span style="color:#E1E4E8">	.bind_class	</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_bind_class,</span></span>
<span class="line"><span style="color:#E1E4E8">	.tmplt_create	</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_tmplt_create,		</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">12</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">	.tmplt_destroy	</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_tmplt_destroy,</span></span>
<span class="line"><span style="color:#E1E4E8">	.tmplt_dump	</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fl_tmplt_dump,</span></span>
<span class="line"><span style="color:#E1E4E8">	.owner		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> THIS_MODULE,</span></span>
<span class="line"><span style="color:#E1E4E8">	.flags		</span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> TCF_PROTO_OPS_DOIT_UNLOCKED,</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span></code></pre>
<p>Following the call chains of these two functions, it’s logical to use <code>fl_dump_key_geneve_opt</code> to retrieve the data we previously passed in.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>fl_dump_key -> fl_dump_key_enc_opt -> fl_dump_key_options->fl_dump_key_geneve_opt</span></span></code></pre>
<p>Let’s take a closer look at <code>fl_dump_key_geneve_opt</code>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">static</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> fl_dump_key_geneve_opt</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> sk_buff </span><span style="color:#F97583">*</span><span style="color:#FFAB70">skb</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">				  struct</span><span style="color:#E1E4E8"> flow_dissector_key_enc_opts </span><span style="color:#F97583">*</span><span style="color:#FFAB70">enc_opts</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> geneve_opt </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">opt;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> nlattr </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">nest;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> opt_off </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">	nest </span><span style="color:#F97583">=</span><span style="color:#B392F0"> nla_nest_start_noflag</span><span style="color:#E1E4E8">(skb, TCA_FLOWER_KEY_ENC_OPTS_GENEVE);</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">nest)</span></span>
<span class="line"><span style="color:#F97583">		goto</span><span style="color:#E1E4E8"> nla_put_failure;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	while</span><span style="color:#E1E4E8"> (enc_opts->len </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> opt_off) {								</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">20</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">		opt </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">enc_opts->data[opt_off];		</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">21</span><span style="color:#E1E4E8">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">nla_put_be16</span><span style="color:#E1E4E8">(skb, TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS,</span></span>
<span class="line"><span style="color:#E1E4E8">				 opt->opt_class))</span></span>
<span class="line"><span style="color:#F97583">			goto</span><span style="color:#E1E4E8"> nla_put_failure;</span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">nla_put_u8</span><span style="color:#E1E4E8">(skb, TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE,</span></span>
<span class="line"><span style="color:#E1E4E8">			       opt->type))</span></span>
<span class="line"><span style="color:#F97583">			goto</span><span style="color:#E1E4E8"> nla_put_failure;</span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">nla_put</span><span style="color:#E1E4E8">(skb, TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA,</span></span>
<span class="line"><span style="color:#E1E4E8">			    opt->length </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">, opt->opt_data))</span></span>
<span class="line"><span style="color:#F97583">			goto</span><span style="color:#E1E4E8"> nla_put_failure;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">		opt_off </span><span style="color:#F97583">+=</span><span style="color:#F97583"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt) </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> opt->length </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">;		</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">22</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"><span style="color:#B392F0">	nla_nest_end</span><span style="color:#E1E4E8">(skb, nest);</span></span>
<span class="line"><span style="color:#F97583">	return</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">nla_put_failure:</span></span>
<span class="line"><span style="color:#B392F0">	nla_nest_cancel</span><span style="color:#E1E4E8">(skb, nest);</span></span>
<span class="line"><span style="color:#F97583">	return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">EMSGSIZE;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><code>fl_dump_key_geneve_opt</code> simply utilizes the previously controlled <code>enc_opts->len</code> to control the length, and copies data based on each <code>opt->length * 4</code>, sending it to user space.</p>
<p>Let’s return to <code>fl_set_geneve_opt</code>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">static</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> fl_set_geneve_opt</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">const</span><span style="color:#F97583"> struct</span><span style="color:#E1E4E8"> nlattr </span><span style="color:#F97583">*</span><span style="color:#FFAB70">nla</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> fl_flow_key </span><span style="color:#F97583">*</span><span style="color:#FFAB70">key</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">			     int</span><span style="color:#FFAB70"> depth</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> option_len</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">			     struct</span><span style="color:#E1E4E8"> netlink_ext_ack </span><span style="color:#F97583">*</span><span style="color:#FFAB70">extack</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> nlattr </span><span style="color:#F97583">*</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> nlattr </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">class </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">type </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">data </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> geneve_opt </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">opt;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> err, data_len </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (option_len </span><span style="color:#F97583">></span><span style="color:#F97583"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt))</span></span>
<span class="line"><span style="color:#E1E4E8">		data_len </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> option_len </span><span style="color:#F97583">-</span><span style="color:#F97583"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">	opt </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">key->enc_opts.data[key->enc_opts.len];	</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#B392F0">	memset</span><span style="color:#E1E4E8">(opt, </span><span style="color:#F97583">0x</span><span style="color:#79B8FF">ff</span><span style="color:#E1E4E8">, option_len);</span></span>
<span class="line"><span style="color:#E1E4E8">	opt->length </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> data_len </span><span style="color:#F97583">/</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	opt->r1 </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	opt->r2 </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">	opt->r3 </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">	/* If no mask has been prodived we assume an exact match. */</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">depth)</span></span>
<span class="line"><span style="color:#F97583">		return</span><span style="color:#F97583"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt) </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> data_len;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">nla_type</span><span style="color:#E1E4E8">(nla) </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> TCA_FLOWER_KEY_ENC_OPTS_GENEVE) {</span></span>
<span class="line"><span style="color:#B392F0">		NL_SET_ERR_MSG</span><span style="color:#E1E4E8">(extack, </span><span style="color:#9ECBFF">"Non-geneve option type for mask"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">		return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">EINVAL;</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">	err </span><span style="color:#F97583">=</span><span style="color:#B392F0"> nla_parse_nested_deprecated</span><span style="color:#E1E4E8">(tb,</span></span>
<span class="line"><span style="color:#E1E4E8">					  TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX,</span></span>
<span class="line"><span style="color:#E1E4E8">					  nla, geneve_opt_policy, extack);					</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (err </span><span style="color:#F97583">&#x3C;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">		return</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">	/* We are not allowed to omit any of CLASS, TYPE or DATA</span></span>
<span class="line"><span style="color:#6A737D">	 * fields from the key.</span></span>
<span class="line"><span style="color:#6A737D">	 */</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">option_len </span><span style="color:#F97583">&#x26;&#x26;</span></span>
<span class="line"><span style="color:#E1E4E8">	    (</span><span style="color:#F97583">!</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS] </span><span style="color:#F97583">||</span></span>
<span class="line"><span style="color:#F97583">	     !</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE] </span><span style="color:#F97583">||</span></span>
<span class="line"><span style="color:#F97583">	     !</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA])) {</span></span>
<span class="line"><span style="color:#B392F0">		NL_SET_ERR_MSG</span><span style="color:#E1E4E8">(extack, </span><span style="color:#9ECBFF">"Missing tunnel key geneve option class, type or data"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">		return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">EINVAL;</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">	/* Omitting any of CLASS, TYPE or DATA fields is allowed</span></span>
<span class="line"><span style="color:#6A737D">	 * for the mask.</span></span>
<span class="line"><span style="color:#6A737D">	 */</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA]) {</span></span>
<span class="line"><span style="color:#F97583">		int</span><span style="color:#E1E4E8"> new_len </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> key->enc_opts.len;								</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">		data </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA];</span></span>
<span class="line"><span style="color:#E1E4E8">		data_len </span><span style="color:#F97583">=</span><span style="color:#B392F0"> nla_len</span><span style="color:#E1E4E8">(data);</span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (data_len </span><span style="color:#F97583">&#x3C;</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">) {												</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#B392F0">			NL_SET_ERR_MSG</span><span style="color:#E1E4E8">(extack, </span><span style="color:#9ECBFF">"Tunnel key geneve option data is less than 4 bytes long"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">			return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">ERANGE;</span></span>
<span class="line"><span style="color:#E1E4E8">		}</span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (data_len </span><span style="color:#F97583">%</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">) {												</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#B392F0">			NL_SET_ERR_MSG</span><span style="color:#E1E4E8">(extack, </span><span style="color:#9ECBFF">"Tunnel key geneve option data is not a multiple of 4 bytes long"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">			return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">ERANGE;</span></span>
<span class="line"><span style="color:#E1E4E8">		}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">		new_len </span><span style="color:#F97583">+=</span><span style="color:#F97583"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt) </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> data_len;</span></span>
<span class="line"><span style="color:#B392F0">		BUILD_BUG_ON</span><span style="color:#E1E4E8">(FLOW_DIS_TUN_OPTS_MAX </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> IP_TUNNEL_OPTS_MAX);</span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (new_len </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> FLOW_DIS_TUN_OPTS_MAX) {							</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">6</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#B392F0">			NL_SET_ERR_MSG</span><span style="color:#E1E4E8">(extack, </span><span style="color:#9ECBFF">"Tunnel options exceeds max size"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">			return</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8">ERANGE;</span></span>
<span class="line"><span style="color:#E1E4E8">		}</span></span>
<span class="line"><span style="color:#E1E4E8">		opt->length </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> data_len </span><span style="color:#F97583">/</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#B392F0">		memcpy</span><span style="color:#E1E4E8">(opt->opt_data, </span><span style="color:#B392F0">nla_data</span><span style="color:#E1E4E8">(data), data_len);				</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">7</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS]) {</span></span>
<span class="line"><span style="color:#E1E4E8">		class </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS];</span></span>
<span class="line"><span style="color:#E1E4E8">		opt->opt_class </span><span style="color:#F97583">=</span><span style="color:#B392F0"> nla_get_be16</span><span style="color:#E1E4E8">(class);</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE]) {</span></span>
<span class="line"><span style="color:#E1E4E8">		type </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> tb</span><span style="color:#E1E4E8">[TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE];</span></span>
<span class="line"><span style="color:#E1E4E8">		opt->type </span><span style="color:#F97583">=</span><span style="color:#B392F0"> nla_get_u8</span><span style="color:#E1E4E8">(type);</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	return</span><span style="color:#F97583"> sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> geneve_opt) </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> data_len;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Triggering the off-by-one requires passing in two or more data packets, with their combined lengths totaling exactly 252 bytes. Using the 4-byte initialization to overwrite <code>key->enc_opts.len</code> allows us to bypass checks [4], [5], and [6]. Due to the checks, the value of <code>key->enc_opts.len</code> can never exceed 255 after a successful <code>memcpy</code>. However, if we need to perform out-of-bounds reads using <code>fl_dump_key_geneve_opt</code>, we must do so under the condition specified at [20], which appears somewhat tricky.</p>
<p>However, if we break out of the cycle of overwriting <code>key->enc_opts.len</code> to bypass detection and perform out-of-bounds access, we should consider another functionality of <code>key->enc_opts.len</code>: locating the position of the array for incoming data packets. The length of each packet header we pass in is also in this array, upon which <code>fl_dump_key_geneve_opt</code> relies for each data read. Since we’ve reset <code>key->enc_opts.len</code> to a value less than 128, we can refill the array and modify <code>opt->length</code>.</p>
<p>Let’s examine this scenario.</p>
<p><img alt="2" loading="lazy" decoding="async" fetchpriority="auto" width="525" height="117" src="/_astro/2.DcZboCqB_ZKuaIW.webp" ></p>
<p>First, we pass in two data packets, as shown in the diagram above, with a total length of exactly 252 bytes, leaving 3 bytes remaining in the array. Then, we pass in another data packet, causing an overflow of 1 byte into <code>key->enc_opts.len</code>.</p>
<p><img alt="3" loading="lazy" decoding="async" fetchpriority="auto" width="525" height="117" src="/_astro/3.xvceX7cZ_Z1jSnQI.webp" ></p>
<p>At this point, we pass in another data packet. Referring back to the <code>geneve_opt</code> structure, we know that the <code>length</code>, <code>r3</code>, <code>r2</code>, and <code>r1</code> fields together form the <code>key->enc_opts.len</code> byte. However, the <code>length</code> field will be assigned the value of the data packet length divided by 4. Therefore, if we overflow with a data packet of 96 bytes in length, <code>key->enc_opts.len</code> will precisely points to the end of the orange section.</p>
<p><img alt="4" loading="lazy" decoding="async" fetchpriority="auto" width="525" height="172" src="/_astro/4.DZWTXMs4_2guXkM.webp" ></p>
<p>Finally, we pass in another data packet, continuously overwriting until the last 252 bytes. With this data packet, we modify the length of the header of the first 120-byte blue packet passed in initially, making it point to a fake head, and forge the fake head in the last four bytes.</p>
<p>Due to the nature of the <code>fl_dump_key_geneve_opt</code> function, as our fake head falls within the length range of <code>key->enc_opts.len</code>, it will read the length of the fake head’s data packet, resulting in an out-of-bounds read of 128 bytes.</p>
<p>With the out-of-bounds read, the <code>chain</code> in the <code>struct fl_flow_tmplt</code> structure serves as our target for heap leakage. In addition to the heap address, we also need function addresses to bypass KASLR protection.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">static</span><span style="color:#F97583"> int</span><span style="color:#B392F0"> fl_change</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> net </span><span style="color:#F97583">*</span><span style="color:#FFAB70">net</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> sk_buff </span><span style="color:#F97583">*</span><span style="color:#FFAB70">in_skb</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">		     struct</span><span style="color:#E1E4E8"> tcf_proto </span><span style="color:#F97583">*</span><span style="color:#FFAB70">tp</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">unsigned</span><span style="color:#F97583"> long</span><span style="color:#FFAB70"> base</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">		     u32 </span><span style="color:#FFAB70">handle</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> nlattr </span><span style="color:#F97583">**</span><span style="color:#FFAB70">tca</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">		     void</span><span style="color:#F97583"> **</span><span style="color:#FFAB70">arg</span><span style="color:#E1E4E8">, u32 </span><span style="color:#FFAB70">flags</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">		     struct</span><span style="color:#E1E4E8"> netlink_ext_ack </span><span style="color:#F97583">*</span><span style="color:#FFAB70">extack</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#E1E4E8">...</span></span>
<span class="line"><span style="color:#E1E4E8">	err </span><span style="color:#F97583">=</span><span style="color:#B392F0"> fl_set_parms</span><span style="color:#E1E4E8">(net, tp, fnew, mask, base, tb, </span><span style="color:#FFAB70">tca</span><span style="color:#E1E4E8">[TCA_RATE],</span></span>
<span class="line"><span style="color:#E1E4E8">			   tp->chain->tmplt_priv, flags, extack);</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (err)</span></span>
<span class="line"><span style="color:#F97583">		goto</span><span style="color:#E1E4E8"> errout;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">	err </span><span style="color:#F97583">=</span><span style="color:#B392F0"> fl_check_assign_mask</span><span style="color:#E1E4E8">(head, fnew, fold, mask);			</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">23</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#F97583">	if</span><span style="color:#E1E4E8"> (err)</span></span>
<span class="line"><span style="color:#F97583">		goto</span><span style="color:#E1E4E8"> errout;</span></span>
<span class="line"><span style="color:#E1E4E8">...</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Examining the function call flow of <code>fl_set_key</code>, at position [23], our passed-in key and mask are processed, and the result is stored in <code>f->mkey</code>. Unlike with the out-of-bounds write, we now have an additional structure, <code>struct fl_flow_mask</code>, that we can perform out-of-bounds reads on.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> fl_flow_mask {</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> fl_flow_key key;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> fl_flow_mask_range range;</span></span>
<span class="line"><span style="color:#E1E4E8">	u32 flags;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> rhash_head ht_node;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> rhashtable ht;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> rhashtable_params filter_ht_params;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> flow_dissector dissector;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> list_head filters;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> rcu_work rwork;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> list_head list;</span></span>
<span class="line"><span style="color:#79B8FF">	refcount_t</span><span style="color:#E1E4E8"> refcnt;</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> rhashtable {</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> bucket_table __rcu	</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">tbl;</span></span>
<span class="line"><span style="color:#F97583">	unsigned</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8">			key_len;</span></span>
<span class="line"><span style="color:#F97583">	unsigned</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8">			max_elems;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> rhashtable_params	p;</span></span>
<span class="line"><span style="color:#F97583">	bool</span><span style="color:#E1E4E8">				rhlist;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> work_struct		run_work;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> mutex                    mutex;</span></span>
<span class="line"><span style="color:#79B8FF">	spinlock_t</span><span style="color:#E1E4E8">			lock;</span></span>
<span class="line"><span style="color:#79B8FF">	atomic_t</span><span style="color:#E1E4E8">			nelems;</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> rhashtable_params {</span></span>
<span class="line"><span style="color:#E1E4E8">	u16			nelem_hint;</span></span>
<span class="line"><span style="color:#E1E4E8">	u16			key_len;</span></span>
<span class="line"><span style="color:#E1E4E8">	u16			key_offset;</span></span>
<span class="line"><span style="color:#E1E4E8">	u16			head_offset;</span></span>
<span class="line"><span style="color:#F97583">	unsigned</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8">		max_size;</span></span>
<span class="line"><span style="color:#E1E4E8">	u16			min_size;</span></span>
<span class="line"><span style="color:#F97583">	bool</span><span style="color:#E1E4E8">			automatic_shrinking;</span></span>
<span class="line"><span style="color:#79B8FF">	rht_hashfn_t</span><span style="color:#E1E4E8">		hashfn;								</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> here</span></span>
<span class="line"><span style="color:#79B8FF">	rht_obj_hashfn_t</span><span style="color:#E1E4E8">	obj_hashfn;</span></span>
<span class="line"><span style="color:#79B8FF">	rht_obj_cmpfn_t</span><span style="color:#E1E4E8">		obj_cmpfn;</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span></code></pre>
<p>After inspecting the structure of <code>fl_flow_mask</code>, we find a function pointer <code>hashfn</code>, which serves as our function pointer to bypass KASLR! In my exploitation, it is assigned the <code>rhashtable_jhash2</code> function.</p>
<h3 id="off-by-one-translates-to-control-flow-hijacking">off-by-one translates to control flow hijacking</h3>
<p>Indeed, the situation is quite clear now.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> fl_flow_tmplt {</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> fl_flow_key dummy_key;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> fl_flow_key mask;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> flow_dissector dissector;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> tcf_chain </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">chain;		</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">24</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> tcf_chain {</span></span>
<span class="line"><span style="color:#6A737D">	/* Protects filter_chain. */</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> mutex filter_chain_lock;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> tcf_proto __rcu </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">filter_chain;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> list_head list;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> tcf_block </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">block;		</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">25</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">	u32 index;</span><span style="color:#6A737D"> /* chain index */</span></span>
<span class="line"><span style="color:#F97583">	unsigned</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8"> refcnt;</span></span>
<span class="line"><span style="color:#F97583">	unsigned</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8"> action_refcnt;</span></span>
<span class="line"><span style="color:#F97583">	bool</span><span style="color:#E1E4E8"> explicitly_created;</span></span>
<span class="line"><span style="color:#F97583">	bool</span><span style="color:#E1E4E8"> flushing;</span></span>
<span class="line"><span style="color:#F97583">	const</span><span style="color:#F97583"> struct</span><span style="color:#E1E4E8"> tcf_proto_ops </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">tmplt_ops;</span></span>
<span class="line"><span style="color:#F97583">	void</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">tmplt_priv;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> rcu_head rcu;</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> tcf_block {</span></span>
<span class="line"><span style="color:#6A737D">	/* Lock protects tcf_block and lifetime-management data of chains</span></span>
<span class="line"><span style="color:#6A737D">	 * attached to the block (refcnt, action_refcnt, explicitly_created).</span></span>
<span class="line"><span style="color:#6A737D">	 */</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> mutex lock;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> list_head chain_list;</span></span>
<span class="line"><span style="color:#E1E4E8">	u32 index;</span><span style="color:#6A737D"> /* block index for shared blocks */</span></span>
<span class="line"><span style="color:#E1E4E8">	u32 classid;</span><span style="color:#6A737D"> /* which class this block belongs to */</span></span>
<span class="line"><span style="color:#79B8FF">	refcount_t</span><span style="color:#E1E4E8"> refcnt;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> net </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">net;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> Qdisc </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">q;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> rw_semaphore cb_lock;</span><span style="color:#6A737D"> /* protects cb_list and offload counters */</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> flow_block flow_block;	</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">26</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">...</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> flow_block_cb {</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> list_head	driver_list;</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> list_head	list;</span></span>
<span class="line"><span style="color:#79B8FF">	flow_setup_cb_t</span><span style="color:#F97583">		*</span><span style="color:#E1E4E8">cb;		</span><span style="color:#F97583">&#x3C;---</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">27</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#F97583">	void</span><span style="color:#F97583">			*</span><span style="color:#E1E4E8">cb_ident;</span></span>
<span class="line"><span style="color:#F97583">	void</span><span style="color:#F97583">			*</span><span style="color:#E1E4E8">cb_priv;</span></span>
<span class="line"><span style="color:#F97583">	void</span><span style="color:#E1E4E8">			(</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">release)(</span><span style="color:#F97583">void</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">cb_priv);</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> flow_block_indr	indr;</span></span>
<span class="line"><span style="color:#F97583">	unsigned</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8">		refcnt;</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span></code></pre>
<p>We need to forge from [24] to [27], which requires full control over our known heap address. Here, I utilize the fuse+setxattr technique for heap spraying, allowing further control over the heap contents. For more information about this technique, refer to the provided links [2] and [4].</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">static</span><span style="color:#F97583"> int</span></span>
<span class="line"><span style="color:#B392F0">__tc_setup_cb_call</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> tcf_block </span><span style="color:#F97583">*</span><span style="color:#FFAB70">block</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">enum</span><span style="color:#E1E4E8"> tc_setup_type </span><span style="color:#FFAB70">type</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">		   void</span><span style="color:#F97583"> *</span><span style="color:#FFAB70">type_data</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">bool</span><span style="color:#FFAB70"> err_stop</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">	struct</span><span style="color:#E1E4E8"> flow_block_cb </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">block_cb;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> ok_count </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">	int</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">	list_for_each_entry</span><span style="color:#E1E4E8">(block_cb, </span><span style="color:#F97583">&#x26;</span><span style="color:#E1E4E8">block->flow_block.cb_list, list) {</span></span>
<span class="line"><span style="color:#E1E4E8">		err </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> block_cb-></span><span style="color:#B392F0">cb</span><span style="color:#E1E4E8">(type, type_data, block_cb->cb_priv);</span></span>
<span class="line"><span style="color:#F97583">		if</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#F97583">			if</span><span style="color:#E1E4E8"> (err_stop)</span></span>
<span class="line"><span style="color:#F97583">				return</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"><span style="color:#E1E4E8">		} </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">			ok_count</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">		}</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"><span style="color:#F97583">	return</span><span style="color:#E1E4E8"> ok_count;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>It’s worth mentioning that, since we can forge the <code>cb</code> virtual function and control the third parameter <code>block_cb->cb_priv</code>, there are two potential privilege escalation strategies: one is direct ROP (Return-Oriented Programming), and the other is to find a suitable function to hijack control flow and convert it into arbitrary address read/write.</p>
<p><img alt="5" loading="lazy" decoding="async" fetchpriority="auto" width="737" height="480" src="/_astro/5.Cdp4niGC_Z14OnUP.webp" ></p>
<p>As shown in the diagram above, we control four registers: <code>rdx</code>, <code>rcx</code> (utilized through multiple loops), <code>rax</code>, and <code>rip</code>. By using appropriate ROP gadgets, executing <code>commit_cred(prepare_kernel_cred(0))</code> can accomplish privilege escalation.</p>
<p>The technique used to return to user mode is <code>swapgs_restore_regs_and_return_to_usermode</code>. For more information on this technique, please refer to the provided link [3].</p>
<p>However, ROP (Return-Oriented Programming) is generally not very stable and requires extensive modifications to adapt to different kernel versions. Therefore, in the final version, I found a suitable function, <code>dbg_set_reg</code>, and <code>dbg_get_reg</code> (these two functions are available by default in Ubuntu), and combined them to modify <code>modprobe_path</code> to achieve privilege escalation.</p>
<h2 id="0x03-the-end">0x03 The End</h2>
<p>Thank you for reading. If you have any questions, feel free to contact us.</p>
<h2 id="0x04-reference">0x04 Reference</h2>
<p><a href="https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html">cve-2021-22555</a></p>
<p><a href="https://www.willsroot.io/2022/01/cve-2022-0185.html">cve-2022-0185</a></p>
<p><a href="https://www.anquanke.com/post/id/240006">KPTI_bypass</a></p>
<p><a href="https://static.sched.com/hosted_files/lsseu2019/04/LSSEU2019%20-%20Exploiting%20race%20conditions%20on%20Linux.pdf">Exploiting_race_conditions_on_ancient_Linux</a></p>
<p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4d56304e5827c8cc8cc18c75343d283af7c4825c">commit</a></p> </div> <div class="text-center mt-8"> <a href="/blog" class="bg-gray-100 px-5 py-3 rounded-md hover:bg-gray-200 transition">← Back to Blog</a> </div>  </div>  <footer class="my-20"> <p class="text-center text-sm text-slate-500">
Copyright © 2025 ShuffleTeam. All rights reserved.
</p> <!--
    Can we ask you a favor 🙏
    Please keep this backlink on your website if possible.
    or Purchase a commercial license from https://web3templates.com

  <p class="text-center text-xs text-slate-500 mt-1">
    Made by <a
      href="https://web3templates.com"
      target="_blank"
      rel="noopener"
      class="hover:underline">
      Web3Templates
    </a>
  </p>
  --> </footer>  </body> </html>