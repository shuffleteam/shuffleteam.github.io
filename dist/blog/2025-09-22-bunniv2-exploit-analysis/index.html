<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/svg+xml" href="/sst.svg"><meta name="generator" content="Astro v5.13.7"><!-- <link rel="preload" as="image" href={src} alt="Hero" /> --><title>BunniV2 Exploit Analysis | Shuffle Team</title><link rel="canonical" href="https://astroship.web3templates.com/blog/2025-09-22-bunniv2-exploit-analysis/"><meta name="description" content="Shuffle Team combines elite human expertise with the power of AI to achieve superior security outcomes. Our security audits and tools are built on this synergy, delivering deeper insights and greater efficiency for your business."><meta name="robots" content="index, follow"><meta property="og:title" content="Shuffle Team"><meta property="og:type" content="website"><meta property="og:image" content="https://astroship.web3templates.com/sst.png"><meta property="og:url" content="https://astroship.web3templates.com/blog/2025-09-22-bunniv2-exploit-analysis/"><meta property="og:image:url" content="https://astroship.web3templates.com/sst.png"><meta property="og:image:alt" content="ShuffleTeam Homepage Screenshot"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@web3templates"><meta name="twitter:creator" content="@wugedbl"><link rel="stylesheet" href="/_astro/about.CGd3VL5k.css"></head> <body> <div class="max-w-(--breakpoint-xl) mx-auto px-5">  <header class="flex flex-col lg:flex-row justify-between items-center my-5">  <div class="flex w-full lg:w-auto items-center justify-between"> <a href="/" class="text-lg"><span class="font-bold text-slate-800">Shuffle</span><span class="text-slate-500">Team</span> </a> <div class="block lg:hidden"> <button id="astronav-menu" aria-label="Toggle Menu">  <svg fill="currentColor" class="w-4 h-4 text-gray-800" width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"> <title>Toggle Menu</title> <path class="astronav-close-icon astronav-toggle hidden" fill-rule="evenodd" clip-rule="evenodd" d="M18.278 16.864a1 1 0 01-1.414 1.414l-4.829-4.828-4.828 4.828a1 1 0 01-1.414-1.414l4.828-4.829-4.828-4.828a1 1 0 011.414-1.414l4.829 4.828 4.828-4.828a1 1 0 111.414 1.414l-4.828 4.829 4.828 4.828z"></path> <path class="astronav-open-icon astronav-toggle" fill-rule="evenodd" d="M4 5h16a1 1 0 010 2H4a1 1 0 110-2zm0 6h16a1 1 0 010 2H4a1 1 0 010-2zm0 6h16a1 1 0 010 2H4a1 1 0 010-2z"></path> </svg>  </button> </div> </div> <nav class="astronav-items astronav-toggle hidden w-full lg:w-auto mt-2 lg:flex lg:mt-0">  <ul class="flex flex-col lg:flex-row lg:gap-3"> <li class="relative"> <menu class="astronav-dropdown group" aria-expanded="false"> <button class="flex items-center gap-1 w-full lg:w-auto lg:px-3 py-2 text-gray-600 hover:text-gray-900"> <span>Services</span> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" class="w-3 h-3 mt-0.5 group-open:rotate-180"> <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5"></path> </svg> </button> <div class="astronav-dropdown dropdown-toggle hidden" aria-expanded="false">  <div class="lg:absolute w-full lg:w-66 z-10 lg:left-0 origin-top-left"> <div class="px-2 py-1.5 lg:bg-white lg:rounded-md lg:shadow-lg lg:border flex flex-col gap-1"> <a href="/en/sas" class="block px-1 py-2 text-gray-600 hover:text-white hover:bg-indigo-600 rounded-md transition-colors"> Security Assessments &amp; Audits </a><a href="/en/csf" class="block px-1 py-2 text-gray-600 hover:text-white hover:bg-indigo-600 rounded-md transition-colors"> Continuous Security &amp; Fuzzing </a><a href="/en/ssa" class="block px-1 py-2 text-gray-600 hover:text-white hover:bg-indigo-600 rounded-md transition-colors"> Strategic Security Advisory </a> </div> </div>  </div> </menu> </li><li> <a href="/blog" class="flex lg:px-3 py-2 items-center text-gray-600 hover:text-gray-900"> <span> Blog</span>  </a> </li><li> <a href="/about" class="flex lg:px-3 py-2 items-center text-gray-600 hover:text-gray-900"> <span> About</span>  </a> </li><li> <a href="/contact" class="flex lg:px-3 py-2 items-center text-gray-600 hover:text-gray-900"> <span> Contact</span>  </a> </li> </ul>   </nav>  <script>(function(){const closeOnClick = false;

["DOMContentLoaded", "astro:after-swap"].forEach((event) => {
  document.addEventListener(event, addListeners);
});

// Function to clone and replace elements
function cloneAndReplace(element) {
  const clone = element.cloneNode(true);
  element.parentNode.replaceChild(clone, element);
}

function addListeners() {
  // Clean up existing listeners
  const oldMenuButton = document.getElementById("astronav-menu");
  if (oldMenuButton) {
    cloneAndReplace(oldMenuButton);
  }

  const oldDropdownMenus = document.querySelectorAll(".astronav-dropdown");
  oldDropdownMenus.forEach((menu) => {
    cloneAndReplace(menu);
  });

  // Mobile nav toggle
  const menuButton = document.getElementById("astronav-menu");
  menuButton && menuButton.addEventListener("click", toggleMobileNav);

  // Dropdown menus
  const dropdownMenus = document.querySelectorAll(".astronav-dropdown");
  dropdownMenus.forEach((menu) => {
    const button = menu.querySelector("button");
    button &&
      button.addEventListener("click", (event) =>
        toggleDropdownMenu(event, menu, dropdownMenus)
      );

    // Handle Submenu Dropdowns
    const dropDownSubmenus = menu.querySelectorAll(
      ".astronav-dropdown-submenu"
    );

    dropDownSubmenus.forEach((submenu) => {
      const submenuButton = submenu.querySelector("button");
      submenuButton &&
        submenuButton.addEventListener("click", (event) => {
          event.stopImmediatePropagation();
          toggleSubmenuDropdown(event, submenu);
        });
    });
  });

  // Clicking away from dropdown will remove the dropdown class
  document.addEventListener("click", closeAllDropdowns);

  if (closeOnClick) {
    handleCloseOnClick();
  }
}

function toggleMobileNav() {
  [...document.querySelectorAll(".astronav-toggle")].forEach((el) => {
    el.classList.toggle("hidden");
  });
}

function toggleDropdownMenu(event, menu, dropdownMenus) {
  toggleMenu(menu);

  // Close one dropdown when selecting another
  Array.from(dropdownMenus)
    .filter((el) => el !== menu && !menu.contains(el))
    .forEach(closeMenu);

  event.stopPropagation();
}

function toggleSubmenuDropdown(event, submenu) {
  event.stopPropagation();
  toggleMenu(submenu);

  // Close sibling submenus at the same nesting level
  const siblingSubmenus = submenu
    .closest(".astronav-dropdown")
    .querySelectorAll(".astronav-dropdown-submenu");
  Array.from(siblingSubmenus)
    .filter((el) => el !== submenu && !submenu.contains(el))
    .forEach(closeMenu);
}

function closeAllDropdowns(event) {
  const dropdownMenus = document.querySelectorAll(".dropdown-toggle");
  const dropdownParent = document.querySelectorAll(
    ".astronav-dropdown, .astronav-dropdown-submenu"
  );
  const isButtonInsideDropdown = [
    ...document.querySelectorAll(
      `.astronav-dropdown button, .astronav-dropdown label, .astronav-dropdown input,
	  .astronav-dropdown-submenu button, .astronav-dropdown-submenu label, .astronav-dropdown-submenu input,
	  #astronav-menu`
    ),
  ].some((button) => button.contains(event.target));
  if (!isButtonInsideDropdown) {
    dropdownMenus.forEach((d) => {
      // console.log("I ran", d);
      // if (!d.contains(event.target)) {
      d.classList.remove("open");
      d.removeAttribute("open");
      d.classList.add("hidden");
      // }
    });
    dropdownParent.forEach((d) => {
      d.classList.remove("open");
      d.removeAttribute("open");
      d.setAttribute("aria-expanded", "false");
    });
  }
}

function toggleMenu(menu) {
  menu.classList.toggle("open");
  const expanded = menu.getAttribute("aria-expanded") === "true";
  menu.setAttribute("aria-expanded", expanded ? "false" : "true");
  menu.hasAttribute("open")
    ? menu.removeAttribute("open")
    : menu.setAttribute("open", "");

  const dropdownToggle = menu.querySelector(".dropdown-toggle");
  const dropdownExpanded = dropdownToggle.getAttribute("aria-expanded");
  dropdownToggle.classList.toggle("hidden");
  dropdownToggle.setAttribute(
    "aria-expanded",
    dropdownExpanded === "true" ? "false" : "true"
  );
}

function closeMenu(menu) {
  // console.log("closing", menu);
  menu.classList.remove("open");
  menu.removeAttribute("open");
  menu.setAttribute("aria-expanded", "false");
  const dropdownToggles = menu.querySelectorAll(".dropdown-toggle");
  dropdownToggles.forEach((toggle) => {
    toggle.classList.add("hidden");
    toggle.setAttribute("aria-expanded", "false");
  });
}

function handleCloseOnClick() {
  const navMenuItems = document.querySelector(".astronav-items");
  const navToggle = document.getElementById("astronav-menu");
  const navLink = navMenuItems && navMenuItems.querySelectorAll("a");

  const MenuIcons = navToggle.querySelectorAll(".astronav-toggle");

  navLink &&
    navLink.forEach((item) => {
      item.addEventListener("click", () => {
        navMenuItems?.classList.add("hidden");
        MenuIcons.forEach((el) => {
          el.classList.toggle("hidden");
        });
      });
    });
}
})();</script> <div slot="actions"> <!-- <a 
  href={targetPath} 
  class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
>
  {buttonText}
</a> --><!-- 如果您更喜欢两个并排的链接，而不是单个切换按钮，可以使用下面的代码 --> </div> <!-- <div>
      <div class="hidden lg:flex items-center gap-4">
        <a href="#">Log in</a>
        <Link href="#" size="md">Sign up</Link>
      </div>
    </div> --> </header>  </div>  <div class="max-w-(--breakpoint-xl) mx-auto px-5">  <div class="mx-auto max-w-3xl mt-14"> <span class="text-blue-400 uppercase tracking-wider text-sm font-medium"> web3 </span> <h1 class="text-4xl lg:text-5xl font-bold lg:tracking-tight mt-1 lg:leading-tight"> BunniV2 Exploit Analysis </h1> <div class="flex gap-2 mt-3 items-center flex-wrap md:flex-nowrap"> <span class="text-gray-400"> shuffle team </span> <span class="text-gray-400">•</span> <time class="text-gray-400" datetime="2025-09-22T00:00:00.000Z"> Mon Sep 22 2025 </time> <span class="text-gray-400 hidden md:block">•</span> <div class="w-full md:w-auto flex flex-wrap gap-3"> <span class="text-sm text-gray-500">#web3</span><span class="text-sm text-gray-500">#hack analysis</span> </div> </div> </div> <div class="mx-auto prose prose-lg mt-6 max-w-3xl"> <!-- # BunniV2 Exploit Analysis -->
<p>在2025年9月2日，黑客利用 Bunni V2的漏洞总共盗取了约 840 万美元，受影响的两个池子分别是 Unichain 上的 weETH/ETH 和 ETH 上的 USDC/USDT。</p>
<p>黑客基本信息：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>攻击交易:</span></span>
<span class="line"><span>* https://etherscan.io/tx/0x1c27c4d625429acfc0f97e466eda725fd09ebdc77550e529ba4cbdbc33beb97b</span></span>
<span class="line"><span>* https://uniscan.xyz/tx/0x4776f31156501dd456664cd3c91662ac8acc78358b9d4fd79337211eb6a1d451</span></span>
<span class="line"><span></span></span>
<span class="line"><span>手续费来源交易： 0x047daf0df44f84a042596b46069842a297a1c81ae7b0372c92c8989bb947ebbc </span></span>
<span class="line"><span>手续费来源地址： 0x5baBE600b9fCD5fB7b66c0611bF4896D967b23A1（Arkham平台标记为 "疑似Gas.zip"）</span></span></code></pre>
<h2 id="漏洞分析">漏洞分析</h2>
<p>本次分析参考以下分析文章：</p>
<ul>
<li><a href="https://blog.bunni.xyz/posts/exploit-post-mortem/#final-words">https://blog.bunni.xyz/posts/exploit-post-mortem/#final-words</a></li>
<li><a href="https://gist.github.com/giovannidisiena/716324d50b6649be3a0e91395890917e">https://gist.github.com/giovannidisiena/716324d50b6649be3a0e91395890917e</a></li>
</ul>
<p>Unichain 上的 weETH/ETH 和 ETH 上的 USDC/USDT 的攻击方式相同，以下使用  ETH 上的 USDC/USDT 进行分析。</p>
<h3 id="漏洞详情">漏洞详情</h3>
<p>在官方给出的漏洞通报中说明了漏洞点出现在 BunniHub::withdraw() 函数：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="solidity"><code><span class="line"><span style="color:#6A737D">// decrease idle balance proportionally to the amount removed</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#E1E4E8">    (</span><span style="color:#79B8FF">uint256</span><span style="color:#E1E4E8"> balance, </span><span style="color:#79B8FF">bool</span><span style="color:#E1E4E8"> isToken0) </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> IdleBalanceLibrary.</span><span style="color:#B392F0">fromIdleBalance</span><span style="color:#E1E4E8">(state.idleBalance);</span></span>
<span class="line"><span style="color:#F97583">>>></span><span style="color:#79B8FF"> uint256</span><span style="color:#E1E4E8"> newBalance </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> balance </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> balance.</span><span style="color:#B392F0">mulDiv</span><span style="color:#E1E4E8">(shares, currentTotalSupply); </span><span style="color:#6A737D">// this line</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (newBalance </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> balance) {</span></span>
<span class="line"><span style="color:#E1E4E8">        s.idleBalance[poolId] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> newBalance.</span><span style="color:#B392F0">toIdleBalance</span><span style="color:#E1E4E8">(isToken0);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>上述代码主要用来处理 withdraw 时更新 idleBalance 的需求。在流动性提供者提取其对应的份额（withdraw shares）时，池子会按比例减少其闲置余额（idleBalance），减少的数量是 balance.mulDiv(shares, currentTotalSupply) 。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="solidity"><code><span class="line"><span style="color:#6A737D">/// </span><span style="color:#F97583">@dev</span><span style="color:#6A737D"> Returns `floor(x * y / d)`.</span></span>
<span class="line"><span style="color:#6A737D">/// Reverts if `x * y` overflows, or `d` is zero.</span></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> mulDiv</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">uint256</span><span style="color:#FFAB70"> x</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">uint256</span><span style="color:#FFAB70"> y</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">uint256</span><span style="color:#FFAB70"> d</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">internal</span><span style="color:#F97583"> pure</span><span style="color:#F97583"> returns</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">uint256</span><span style="color:#FFAB70"> z</span><span style="color:#E1E4E8">) {...}</span></span></code></pre>
<p>需要注意的是，这里特意使用了 <strong>mulDiv</strong> 对结果进行向下取整，这是因为项目方认为这样的操作会对应的让 idleBalance 向上取整，从而使得 activeBalance 向下取整。这在 defi 的开发过程中被认为是一种安全的取整方向，因为较低的流动性会让 swap 的过程中价格变化更大，从而使池子受益（其实这是一种低估的假设，如果低估了池子中的流动性，那么会使 swap / redeem 变得更困难，获得的 token 越少）。</p>
<h2 id="攻击流程">攻击流程</h2>
<p>此次漏洞利用主要是分为以下三步：</p>
<ul>
<li>
<p><strong>Swap</strong>
攻击者首先闪电贷了 3m USDT，然后进行了多次 swap 将池子里的 spot price tick 抬高至 5000。最关键的是，使用精心构造的参数进行 swap，将池子里的 USDC 的 activeBalance0 （活跃余额，即用于提供兑换流动性的 USDC 数量）从 1.835280870463e12 减少到 25 wei。</p>
</li>
<li>
<p><strong>Withdraw</strong></p>
<p>攻击者进行了 44 次小额提现，利用 <strong>RoundingDown</strong> 漏洞将 USDC 的 activeBalance0 从 25 wei 降至 3 wei，降幅达 88%，并使得池子里的 totalLiquidity 错误地从 5.83e16 降至 9.114e15，降幅达 84.4%。</p>
</li>
<li>
<p><strong>SwapBack</strong></p>
<p>随着流动性的下降，攻击者进行了大额的 USDT -> USDC swap，进一步推高 spot price tick 至 839189（相当于1 USDC = 2.77e36 USDT）。第一次 swap 导致池子的 totalLiquidity 从 9.114e15 增加到 1.065e16，<strong>反向增加了16.8%</strong>（与 步骤2 中的 totalLiquidity 的下降趋势相反）。随后，攻击者以这个虚高的价格进行了 USDC -> USDT swap，由于流动性的增加，攻击者得以获利。</p>
</li>
</ul>
<p>最后，在偿还步骤1中的闪电贷后，攻击者获得约 1.33m USDC 和约 1m USDT 的利润。</p>
<h3 id="攻击前">攻击前</h3>
<p>关键变量：</p>
<ul>
<li>
<p>pool balance：</p>
<ul>
<li>activeBalance：活跃的 token ，用于提供 swap 的流动性。</li>
<li>idleBalance：闲置的 token。在提供新流动性时，多余的 token0 有可能放不进 Uniswap V3 头寸里（因为当前价格已经很靠右，可能完全不需要  token0 ），这时候就会暂存到  idleBalance 。此部分不会用于提供流动性，除非进行 rebalancing / surge。</li>
</ul>
</li>
<li>
<p>token0/token1 balance：token0 或者 token1 的数量</p>
<ul>
<li>balance0 = rawBalance0 + previewRedeem(reserve0)</li>
<li>balance1 = rawBalance1 + previewRedeem(reserve1)</li>
</ul>
</li>
<li>
<p>totalLiquidityEstimate：以 token0 或者 token1 来预估整个池子的流动性</p>
<ul>
<li>uint256 totalLiquidityEstimate0 = balance0.fullMulDiv(Q96, totalDensity0X96)</li>
<li>uint256 totalLiquidityEstimate1 = balance1.fullMulDiv(Q96, totalDensity1X96)</li>
</ul>
</li>
<li>
<p>updatedBalance0（queryLDF 函数中用于计算 activeBalance 的临时变量）</p>
<ul>
<li>updatedBalance0 = balance0 - idleBalance (QueryLDF.sol: line 85-92)</li>
</ul>
</li>
</ul>
<p>受影响的池子特征：</p>
<ul>
<li><strong>地毯式双几何流动性分布函数（CarpetedDoubleGeometricLiquidityDistributionFunction）</strong>：流动性可以在 TWAP 周期内双向对称移动，防止触发 surge fee；</li>
<li>较小的 tick spacing： tick spacing 为 1。允许对 activeBalance 和 idleBalance 进行非常细粒度的操控；</li>
<li>代币对称性： USDC/USDT 和 ETH/weETH 的价格接近平价，允许在不触及价格限制的情况下在任一方向进行大额互换；</li>
<li>操作难度： 该漏洞需要精心策划并精确计算互换/提现，才能利用非常细微的舍入误差和流动性计算。</li>
</ul>
<p>USDC/USDT 池子最开始的状态为：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#B392F0">token0</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">USDC</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">token1</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">USDT</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">start </span><span style="color:#B392F0">poolState</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#B392F0">reverse0</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">1707778140002</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">reverse1</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">806866315406</span></span>
<span class="line"><span style="color:#B392F0">rawBalance0</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">356233315494</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">rawBalance1</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">235446423830</span></span>
<span class="line"><span style="color:#B392F0">balance0</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">2152001610969</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">balance1</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">1079504135619</span></span>
<span class="line"><span style="color:#B392F0">idleBalance</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">316691975954</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">isToken0</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">sqrtPriceX96</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">79226236828369675893154619303</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">tick</span><span style="color:#E1E4E8">: </span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">LDF</span><span style="color:#E1E4E8">(Liquidity Density Function):</span></span>
<span class="line"><span style="color:#B392F0">liquidityDensityOfRoundedTickX96</span><span style="color:#E1E4E8">(liquidityDensityX96_): </span><span style="color:#79B8FF">21127509982676313354474563397</span></span>
<span class="line"><span style="color:#B392F0">density0RightOfRoundedTickX96</span><span style="color:#E1E4E8">(cumulativeAmount0DensityX96): </span><span style="color:#79B8FF">1980482907221483874998123</span></span>
<span class="line"><span style="color:#B392F0">density1LeftOfRoundedTickX96</span><span style="color:#E1E4E8">(cumulativeAmount1DensityX96): </span><span style="color:#79B8FF">924186629648334027225499</span></span>
<span class="line"><span style="color:#B392F0">totalLiquidity</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">58302026139899290</span></span>
<span class="line"><span style="color:#B392F0">totalDensity0X96</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">2494011626894250147759228</span></span>
<span class="line"><span style="color:#B392F0">totalDensity1X96</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">1466966669158546676419635</span></span>
<span class="line"><span style="color:#B392F0">liquidityDensityOfRoundedTickX96</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">21127509982676313354474563397</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">activeBalance0</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">1835280870463</span></span>
<span class="line"><span style="color:#B392F0">activeBalance1</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">1079504135618</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">shouldSurge</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">false</span></span>
<span class="line"><span style="color:#B392F0">updatedBalance0</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">1835309635015</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">totalLiquidityEstimate0</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">58302939913731650</span></span>
<span class="line"><span style="color:#B392F0">totalLiquidityEstimate1</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">58302026139899289</span></span>
<span class="line"><span style="color:#E1E4E8">totalLiquidityEstimate0.</span><span style="color:#B392F0">fullMulX96</span><span style="color:#E1E4E8">(totalDensity0X96): </span><span style="color:#79B8FF">1835309635014</span></span>
<span class="line"><span style="color:#E1E4E8">totalLiquidityEstimate0.</span><span style="color:#B392F0">fullMulX96</span><span style="color:#E1E4E8">(totalDensity1X96): </span><span style="color:#79B8FF">1079521054801</span></span>
<span class="line"><span style="color:#E1E4E8">totalLiquidityEstimate1.</span><span style="color:#B392F0">fullMulX96</span><span style="color:#E1E4E8">(totalDensity0X96): </span><span style="color:#79B8FF">1835280870463</span></span>
<span class="line"><span style="color:#E1E4E8">totalLiquidityEstimate1.</span><span style="color:#B392F0">fullMulX96</span><span style="color:#E1E4E8">(totalDensity1X96): </span><span style="color:#79B8FF">1079504135618</span></span></code></pre>
<h3 id="攻击详细步骤">攻击详细步骤</h3>
<ol>
<li>
<p><strong>Swap</strong></p>
<p>目标：减小 activeBalance0 。</p>
<p>方法：使用精心构造的参数（exactIn/exactOut/exactin）进行 3 次 swap，逐步将池子中 USDC 兑换为 USDT，抬高池子的 USDC/USDT 价格，并将 activeBalance0 降低至 26 wei。</p>
</li>
</ol>
<ul>
<li>swap 1 （balance totalLiquidityEstimate0 &#x26; totalLiquidityEstimate1）</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#79B8FF">1.7088106e7</span><span style="color:#79B8FF"> USDT</span><span style="color:#F97583"> -></span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8"> wei </span><span style="color:#79B8FF">USDC</span><span style="color:#E1E4E8">, exactIn</span></span>
<span class="line"><span style="color:#B392F0">tick</span><span style="color:#E1E4E8">: </span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">~</span><span style="color:#79B8FF">0.9999</span><span style="color:#79B8FF"> USDT</span><span style="color:#E1E4E8"> per </span><span style="color:#79B8FF">USDC</span></span>
<span class="line"><span style="color:#B392F0">sqrtPriceLimitX96</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">79226236828369693485340663719</span><span style="color:#E1E4E8"> (pool.slot0s.sqrtPriceX96 </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 2</span><span style="color:#F97583">**</span><span style="color:#79B8FF">44</span><span style="color:#E1E4E8">), tick </span><span style="color:#B392F0">limit</span><span style="color:#E1E4E8">: </span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span></span></code></pre>
<p>swap 1 前后的参数变化：</p>
<p><img alt="image-20250914011750017" loading="lazy" decoding="async" fetchpriority="auto" width="2862" height="1372" src="/_astro/image-20250914011750017.l3KAXlO4_1RsB6c.webp" ></p>
<p>攻击者在 swap 1 使用的 sqrtPriceLimitX96 只比最开始池子的当前价格（sqrtPriceX96）大 2**44。这是一个很小的价格区间，BunniHub 在处理这种 swap 时，会根据这个区间内的流动性计算需要的 inputToken 和 outputToken（v3特性），然后把剩余的 inputToken 直接作为池子的 rawBalance 添加到池子中。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="solidity"><code><span class="line"><span style="color:#E1E4E8">BunniHub</span><span style="color:#F97583">:</span><span style="color:#B392F0">hookHandleSwap</span><span style="color:#E1E4E8">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">// pull input claim tokens from hook</span></span>
<span class="line"><span style="color:#F97583">if</span><span style="color:#E1E4E8"> (inputAmount </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">	zeroForOne </span><span style="color:#F97583">?</span><span style="color:#E1E4E8"> state.rawBalance0 </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> inputAmount </span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> state.rawBalance1 </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> inputAmount;</span></span>
<span class="line"><span style="color:#E1E4E8">	poolManager.</span><span style="color:#B392F0">transferFrom</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">address</span><span style="color:#E1E4E8">(key.hooks), </span><span style="color:#79B8FF">address</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">), inputToken.</span><span style="color:#B392F0">toId</span><span style="color:#E1E4E8">(), inputAmount);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>swap 1的结果是攻击者使用了 1.7088106e7 只兑换出了 2 wei USDC。根据此时的价格（~0.9999 USDT per USDC），单看这个兑换率是不对的，但这也正是攻击者的目的。这么做会将大部分的 inputToken 直接添加进 rawBalance 中，从而增大 rawBalance1 和 totalLiquidityEstimate1。此时 <strong>totalLiquidityEstimate0 刚好略小于 totalLiquidityEstimate1</strong>，为接下来 swap 2 做好了准备。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>uint256 totalLiquidityEstimate1 = balance1.fullMulDiv(Q96, totalDensity1X96);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>rawBalance1⬆️ -> balance1⬆️ -> totalLiquidityEstimate1⬆️ -> totalLiquidityEstimate1 > totalLiquidityEstimate0✅</span></span></code></pre>
<ul>
<li>swap 2 （reduce activeBalance0 to 499 wei）</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="solidity"><code><span class="line"><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">835492291952e12</span><span style="color:#E1E4E8"> USDT </span><span style="color:#F97583">-></span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">835309634512e12</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1835309635012</span><span style="color:#F97583"> -</span><span style="color:#79B8FF"> 500</span><span style="color:#E1E4E8">) USDC, exactOut</span></span>
<span class="line"><span style="color:#E1E4E8">tick</span><span style="color:#F97583">:</span><span style="color:#F97583"> -</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, ~</span><span style="color:#79B8FF">0.9999</span><span style="color:#E1E4E8"> USDT per USDC</span></span>
<span class="line"><span style="color:#E1E4E8">sqrtPriceLimitX96</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 1461446703485210103287273052203988822378723970341</span><span style="color:#E1E4E8">, tick limit</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> 887272</span><span style="color:#E1E4E8">(max tickPrice)</span></span></code></pre>
<p>swap 2 前后的参数变化：</p>
<p><img alt="image-20250914014148538" loading="lazy" decoding="async" fetchpriority="auto" width="3206" height="1436" src="/_astro/image-20250914014148538.CLnBYAN5_Z21jUID.webp" ></p>
<p>攻击者在 swap 2 中使用 exactOut 准确的将 token0 的 activeBalance0 尽可能的全部兑换出来（兑换的数量为 activeBalance0 - 500）。</p>
<p>以下两个条件使得 activeBalance0 能够到达 499 wei：</p>
<ul>
<li>当 totalLiquidityEstimate0 &#x3C; totalLiquidityEstimate1 时，使用 totalLiquidityEstimate0 来计算 totalLiquidity 和 activeBalance（<strong>较小原则</strong>），swap 2 由 token0 来做约束。</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>- fullMulX96 （向下取整）使得计算出来的 activeBalance0 会比 updatedBalance0 小 1。</span></span></code></pre>
<p>如果 LDF 使用的不是 totalLiquidityEstimate0 进行计算，那么就无法精准的控制 swap 2 后的 activeBalance0。</p>
<ul>
<li>swap 3 （reduce activeBalance0 to 25 wei）</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#E1E4E8">swap </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#79B8FF">1e6</span><span style="color:#79B8FF"> USDT</span><span style="color:#F97583"> -></span><span style="color:#79B8FF"> 472</span><span style="color:#E1E4E8"> wei </span><span style="color:#79B8FF">USDC</span><span style="color:#E1E4E8">, exactIn</span></span>
<span class="line"><span style="color:#B392F0">tick</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">~</span><span style="color:#79B8FF">1.0003</span><span style="color:#79B8FF"> USDT</span><span style="color:#E1E4E8"> per </span><span style="color:#79B8FF">USDC</span></span>
<span class="line"><span style="color:#B392F0">sqrtPriceLimitX96</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">101729702841318637793976746270</span><span style="color:#E1E4E8">, tick </span><span style="color:#B392F0">limit</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">5000</span></span></code></pre>
<p>swap 3 前后的参数变化：</p>
<p><img alt="image-20250914014220737" loading="lazy" decoding="async" fetchpriority="auto" width="3208" height="1434" src="/_astro/image-20250914014220737.Dsna8HR0_ZVTNY2.webp" ></p>
<p>攻击者在 swap 3 中使用了一个**精校好的数字（1e6 USDT）**兑换 USDC， 使得 activeBalanace0 的数值进一步降低至 25 wei（swap 3 结束后totalLiquidityEstimate1 &#x3C; totalLiquidityEstimate0，使用 totalLiquidityEstimate1 计算 totalLiquidity 和 activeBalance0）。</p>
<p>至此，攻击者的精心构造的第一步 swap 已经全部完成，三次 swap 均发生在一次 uniswapv4 unlock 中。攻击者总共损耗了 1.835510380058e12 USDT，获得了 1.835309634986e12 USDC， 完成 uniswapv4 的平账操作。此时池子的 activeBalance0 从 1835280870463 骤降至 25 wei，为接下来攻击者的 <strong>Rounding Trick</strong> 操作做好了准备。</p>
<p>需要留意到的是：shouldSurge 一直为 false / slot0s.lastSurgeTimestamp 没有变化，这意味着 <strong>LDF 没有发生过移动 / 改变</strong>。</p>
<ol start="2">
<li>
<p><strong>Withdraw</strong></p>
<p>目标：通过反复 withdraw shares，进一步降低 activeBalance0 到一个极小的值 （<strong>3 wei</strong>）。</p>
<p>方法：攻击者在这里利用了 <strong>Rounding Down</strong> 的漏洞，执行大量的小额 withdraw shares 操作。因为 withdraw 不会影响池子里的价格，所以 totalDensity0 不会变化，但会让 activeBalance0 和 idleBalance 进一步下降，导致 totalLiquidity 从 5.8303205157163981e16 减少至 9.114083388149667e15，  activeBalance0 从 25 wei 减少至 3 wei。</p>
<p>BunniHubLogic::withdraw 函数旨在按比例减少 idleBalance，使其与被移除的活跃流动性成比例。然而 <strong>mulDiv</strong> 计算会向下舍入，从而将 withdraw 后的 idleBalance （updatedIdleBalance0）向上舍入。同时，在计算 totalLiquidity 使用的基本上与 totalLiquidityEstimate 相同的逻辑，这意味着 totalLiquidity 会随着 updatedBalance0 的减小而成比例的减小。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="solidity"><code><span class="line"><span style="color:#B392F0">Withdraw</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> </span></span>
<span class="line"><span style="color:#79B8FF">uint256</span><span style="color:#E1E4E8"> idleBalance </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> idleBalance </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> idleBalance.</span><span style="color:#B392F0">mulDiv</span><span style="color:#E1E4E8">(shares, currentTotalSupply);</span></span>
<span class="line"><span style="color:#79B8FF">uint256</span><span style="color:#E1E4E8"> balance0 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ( rawbalance0 </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> rawbalance0.</span><span style="color:#B392F0">mulDiv</span><span style="color:#E1E4E8">(shares, currentTotalSupply) ) </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> </span></span>
<span class="line"><span style="color:#B392F0">									previewRedeem</span><span style="color:#E1E4E8">(reserve0) </span><span style="color:#F97583">-</span><span style="color:#B392F0"> previewRedeem</span><span style="color:#E1E4E8">(reserve0.</span><span style="color:#B392F0">mulDiv</span><span style="color:#E1E4E8">(shares, currentTotalSupply));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">floor</span><span style="color:#E1E4E8">(idleBalance </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> shares </span><span style="color:#F97583">/</span><span style="color:#E1E4E8"> totalSupply)⬇️ </span><span style="color:#F97583">-></span><span style="color:#E1E4E8"> idleBalance </span><span style="color:#F97583">-</span><span style="color:#B392F0"> floor</span><span style="color:#E1E4E8">(idleBalance </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> shares </span><span style="color:#F97583">/</span><span style="color:#E1E4E8"> totalSupply)⬆️</span></span></code></pre>
<p>QueryLDF.sol::QueryLDF 函数旨在计算 activeBalance0 和 totalLiquidity，核心逻辑如下：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="solidity"><code><span class="line"><span style="color:#B392F0">QueryLDF</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">:</span></span>
<span class="line"><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">uint256</span><span style="color:#E1E4E8"> balance, </span><span style="color:#79B8FF">bool</span><span style="color:#E1E4E8"> isToken0) </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> IdleBalanceLibrary.</span><span style="color:#B392F0">fromIdleBalance</span><span style="color:#E1E4E8">(idleBalance);</span></span>
<span class="line"><span style="color:#E1E4E8">balance0 </span><span style="color:#F97583">=</span><span style="color:#B392F0"> subReLU</span><span style="color:#E1E4E8">(balance0, balance); </span><span style="color:#6A737D">// updatedBalance0</span></span>
<span class="line"><span style="color:#E1E4E8">            </span></span>
<span class="line"><span style="color:#79B8FF">uint256</span><span style="color:#E1E4E8"> totalLiquidityEstimate0 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> updatedBalance0.</span><span style="color:#B392F0">fullMulDiv</span><span style="color:#E1E4E8">(Q96, totalDensity0X96);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">if</span><span style="color:#E1E4E8"> (totalLiquidityEstimate0 </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> totalLiquidityEstimate1) {</span></span>
<span class="line"><span style="color:#E1E4E8">  totalLiquidity </span><span style="color:#F97583">=</span><span style="color:#B392F0"> roundUpFullMulDivResult</span><span style="color:#E1E4E8">(updatedBalance0, Q96, totalDensity0X96, totalLiquidityEstimate0);</span></span>
<span class="line"><span style="color:#E1E4E8">  (activeBalance0, activeBalance1) </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">    FixedPointMathLib.</span><span style="color:#B392F0">min</span><span style="color:#E1E4E8">(balance0, totalLiquidityEstimate0.</span><span style="color:#B392F0">fullMulX96</span><span style="color:#E1E4E8">(totalDensity0X96)),</span></span>
<span class="line"><span style="color:#E1E4E8">  	FixedPointMathLib.</span><span style="color:#B392F0">min</span><span style="color:#E1E4E8">(balance1, totalLiquidityEstimate0.</span><span style="color:#B392F0">fullMulX96</span><span style="color:#E1E4E8">(totalDensity1X96))</span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  totalLiquidity </span><span style="color:#F97583">=</span><span style="color:#B392F0"> roundUpFullMulDivResult</span><span style="color:#E1E4E8">(updatedBalance1, Q96, totalDensity1X96, totalLiquidityEstimate1);</span></span>
<span class="line"><span style="color:#E1E4E8">  (activeBalance0, activeBalance1) </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">   FixedPointMathLib.</span><span style="color:#B392F0">min</span><span style="color:#E1E4E8">(balance0, totalLiquidityEstimate1.</span><span style="color:#B392F0">fullMulX96</span><span style="color:#E1E4E8">(totalDensity0X96)),</span></span>
<span class="line"><span style="color:#E1E4E8">   FixedPointMathLib.</span><span style="color:#B392F0">min</span><span style="color:#E1E4E8">(balance1, totalLiquidityEstimate1.</span><span style="color:#B392F0">fullMulX96</span><span style="color:#E1E4E8">(totalDensity1X96))</span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>回到攻击者这边，攻击者精心构造了每次 withdraw shares 的数量，从而让 activeBalance0 能够从 25 wei 逐渐降至 3 wei，同时 totalLiquidity 从 5.8303205157163981e16 逐渐将至 0.9114083388149667e16。</p>
<p>部分 withdrawal 后的参数变化：</p>
<p><img alt="image-20250914020525202" loading="lazy" decoding="async" fetchpriority="auto" width="4310" height="992" src="/_astro/image-20250914020525202.BXdc8wQ4_rFa6o.webp" ></p>
<p>攻击者从第二次 withdrawal 开始，每次 withdraw shares 的数量均为 3.31262636100e11，每次减小的 idleBalance 为：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>floor(3.16691975216e11 * 3.31262636100e11 / 1596.285784192335992906e18) = floor(65.72) = 65</span></span></code></pre>
<p>除了更新 idleBalance 时会进行向下取整， previewRedeem 在计算的时候也会进行向下取整，所以导致 delta previewRedeem(rawBalance0) 的数量可能会多 1 wei。比如说从 withdrawal 12 ~ 13 中，balance0 和 idleBalance 减小的数量均为 65 wei，而 withdrawal 13 ~ 14中，balance0 比 idleBalance 多减小了1 wei。这减小的 1 wei 会通过影响 QueryLDF 函数中 balance0 临时变量的更新（updatedBalance0），从而最终导致 activeBalance0 减小 1 wei。经过多次类似的 withdrawal 操作，activeBalance0 最终降低到 3 wei。</p>
<p>44 withdrawal 后的参数变化：</p>
<p><img alt="image-20250913123917118" loading="lazy" decoding="async" fetchpriority="auto" width="2812" height="1578" src="/_astro/image-20250913123917118.DN9lSEOr_Zxs5ab.webp" ></p>
<p>至此，攻击者仅使用了极少量（1.4363547901296e13）的 lp 就将池子中的 activeBalance0 和 totalLiquidity 下降到了一个接近于临界值的位置。</p>
</li>
<li>
<p><strong>SwapBack</strong></p>
<p>目标：<strong>“突增”流动性</strong>，并以虚高的价格兑换 USDC。</p>
<p>方法：执行两次 swap 。第 1 次 swap 使用大额的 USDT 兑换 USDC ，进一步推高价格 tick（839189，或约 2.78e36 USDT/USDC），同时还 “错误的” 增加了额外的总流动性。第 2 次 swap 使用第 1 次 swap 额外添加的流动性，将池子内的 USDT 兑换回 USDC， 实现最终的获利。依托于 uniswapv4 的 <strong>Flash Accounting</strong> 特性，攻击者只需要在最后一步计算消耗的 token 和获得的 token ，并调用 take，sync 和 settle 完成平账操作即可，因此攻击者可以在 swap 4 中使用远超于 uniswap v4 中所拥有的 USDT 数量来进行 swap 操作（本质上是在进行 uniswap v3 的 swap 计算，并不涉及到真正的 token transfer）。</p>
<ul>
<li>
<p>swap 4 （swap giant amount of USDT to USDC）</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>swap 4:</span></span>
<span class="line"><span>1e19 USDT -> 1 wei USDC, exactIn</span></span>
<span class="line"><span>tick: 5000, ~1.6487 USDT per USDC</span></span>
<span class="line"><span>sqrtPriceLimitX96: 1461446703485210103287273052203988822378723970341, tick limit: 887272 (TickMath.MAX_TICK)</span></span></code></pre>
<p>swap 4 前后的参数变化：</p>
<p><img alt="image-20250914020135697" loading="lazy" decoding="async" fetchpriority="auto" width="2918" height="1186" src="/_astro/image-20250914020135697.Dqb93Szv_12lEpF.webp" ></p>
<p>攻击者在 swap 4 中使用 1e19 数量的 USDT 尽可能的去换取池子内的所有 USDC。因为 LDF 使用的是 CarpetedDoubleGeometricDistribution 策略，他有以下几个特点：1）在主价格区间用几何分布方式集中流动性；2）在区间外用均匀分布的 “carpet” 保证所有 tick 都有流动性。这保证了即使在与 twap 价格相差十分大的价格区间也会拥有少量的流动性，使得 swap 能够正常进行（虽然这会造成不小的损失）。</p>
<p>swap 4 后池子处于一个极度倾斜的状态（拥有大量的 USDT 但仅拥有少量的 USDC）。此时池子的价格 tick 为 839189，兑换率约 2.78e36 USDT/USDC，balance0 全部都由 idleBalance 提供，池子内已经没有任何的 activeBalance0 可供兑换。</p>
</li>
<li>
<p>swap 5</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>swap 5:</span></span>
<span class="line"><span>5.03177409646e11 USDC -> 1.0000002885864344623e19 USDT, exactOut</span></span>
<span class="line"><span>tick: 839189, ~2.78e36 USDT per USDC</span></span>
<span class="line"><span>sqrtPriceLimitX96: 4295128740, tick limit: -887272 (TickMath.MIN_TICK)</span></span></code></pre>
<p>swap 5 前后的参数变化：</p>
<p><img alt="image-20250914142352010" loading="lazy" decoding="async" fetchpriority="auto" width="2960" height="1182" src="/_astro/image-20250914142352010.CvSHUwQx_PUV4Y.webp" ></p>
<p>攻击者在 swap 5 中使用 exactOut 计算并兑换 swap 4中消耗的 USDT（实际上为99%）。<strong>原先由 totalLiquidityEstimate0 提供的 totalLiquidity 也因为 token0 流动性枯竭的原因，转而由 totalLiquidityEstimate1 提供</strong>。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>totalLiquidityEstimate0 =（updatedBalance0 * 2**96 / totalDensity0X96）= 237684487542793012780631851008</span></span>
<span class="line"><span>totalLiquidityEstimate1 =（balance1 * 2**96 / totalDensity1X96）= 10647207614202720</span></span>
<span class="line"><span>result: totalLiquidityEstimate1 &#x3C; totalLiquidityEstimate0</span></span></code></pre>
<p>因为 <strong>LiquidityEstimate 的转变，池子在这个虚高的位置获得了额外的（约16%）流动性</strong>，从而使得攻击者能够在 swap 5 中使用更少的 token0（USDC）兑换出等量的 USDT ，最终实现获利。</p>
<p>至此，攻击者总共损耗了 5.03177409645e11 USDC， 获得了 2.885864344623e12 USDT。加上第一步 swap 的损耗和获利，攻击者总共获得了 1.332132228158e12 USDC 和 1.04145399071e12 USDT，约为 2.3m 美金。</p>
</li>
</ul>
</li>
</ol>
<h2 id="拓展">拓展</h2>
<ul>
<li>
<p>攻击者在攻击发生十天前在 eth 链上先进行了一步正常的提供流动性的操作，这可能意味着攻击者在此刻就已经知晓了漏洞，为了测试漏洞时方便，而在链上提前完成了获取 lp 的步骤。</p>
</li>
<li>
<p>swap 1 主要的作用是让 totalLiquidityEstimate0 刚好略小于 totalLiquidityEstimate1，那么其实可以提供比较多的 USDT（token1）。只要设置好sqrtPriceLimitX96，那么多余的 token1 都会被作为 rawBalance1，进而增大 totalLiquidityEstimate1。</p>
</li>
<li>
<p>在计算 withdraw shares 的具体数量时，可以用 python 暴力计算 withdrawal 的整个过程，有很多 shares 区间都可以达到目标，但是可能需要测试一下 withdrawal 的次数。</p>
<p>但并不是说 shares 大于某个数或者在某个区间的所有值都可以完成攻击，以下是一部分可用的结果：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>205400000000 (19, 12)			331300000000 (19, 11)				457200000000 (19, 11)</span></span>
<span class="line"><span>205500000000 (19, 12)			331400000000 (19, 11)				457300000000 (19, 11)</span></span>
<span class="line"><span>205600000000 (19, 12)			331500000000 (19, 11)				457400000000 (19, 11)</span></span>
<span class="line"><span>205700000000 (19, 12)			331600000000 (19, 11)				457500000000 (19, 11)</span></span>
<span class="line"><span>205800000000 (19, 12)			331700000000 (19, 11)				457600000000 (19, 11)</span></span>
<span class="line"><span>205900000000 (19, 12)			331800000000 (19, 11)				457700000000 (19, 11)</span></span>
<span class="line"><span>206000000000 (19, 12)			331900000000 (19, 11)				457800000000 (19, 11)</span></span>
<span class="line"><span>206100000000 (19, 12)			332000000000 (19, 11)				457900000000 (19, 11)</span></span>
<span class="line"><span>206200000000 (19, 12)			332100000000 (19, 11)				458000000000 (19, 11)</span></span>
<span class="line"><span>206300000000 (19, 12)			332200000000 (19, 11)				458100000000 (19, 11)</span></span>
<span class="line"><span>206400000000 (19, 12)			332300000000 (19, 11)				458200000000 (19, 11)</span></span>
<span class="line"><span>206500000000 (19, 12)			332400000000 (19, 11)				458300000000 (19, 11)</span></span>
<span class="line"><span>206600000000 (19, 12)			332500000000 (19, 11)				458400000000 (19, 11)</span></span>
<span class="line"><span>                          332600000000 (19, 11)				458500000000 (19, 11)</span></span>
<span class="line"><span>                          357800000000 (19, 15)				458600000000 (19, 11)</span></span>
<span class="line"><span>                                                 			483700000000 (19, 15)</span></span>
<span class="line"><span>                                                 			483800000000 (19, 15)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>括号中第一个参数为 withdraw 次数，第二个参数为abs(deltaActiveBalance)</span></span>
<span class="line"><span>比如说 205400000000 (19, 12) : shares 为 205400000000, 19 次 withdrawal 有 12 次 withdrawal 均减小了 1</span></span></code></pre>
</li>
<li>
<p>如果最终控制 activeBalance0 为 2 的话，那么攻击者大概还能多获取 200k 美金的收益。没有这么做的原因可能是 activeBalance0 为 2 离临界值太近，可能会导致后续步骤报错。</p>
<p>以下参数均可以完成攻击：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>withdrawSharesAmount: 205900000000, iter: 42, profit: 1.509580494886e12 usdc + 1.04145398069e12 usdt</span></span>
<span class="line"><span>withdrawSharesAmount: 331600000000, iter: 44, profit: 1.509580494886e12 usdc + 1.04145398069e12 usdt</span></span>
<span class="line"><span>withdrawSharesAmount: 457700000000, iter: 46, profit: 1.509580494886e12 usdc + 1.04145398069e12 usdt</span></span></code></pre>
</li>
</ul> </div> <div class="text-center mt-8"> <a href="/blog" class="bg-gray-100 px-5 py-3 rounded-md hover:bg-gray-200 transition">← Back to Blog</a> </div>  </div>  <footer class="my-20"> <p class="text-center text-sm text-slate-500">
Copyright © 2025 ShuffleTeam. All rights reserved.
</p> <!--
    Can we ask you a favor 🙏
    Please keep this backlink on your website if possible.
    or Purchase a commercial license from https://web3templates.com

  <p class="text-center text-xs text-slate-500 mt-1">
    Made by <a
      href="https://web3templates.com"
      target="_blank"
      rel="noopener"
      class="hover:underline">
      Web3Templates
    </a>
  </p>
  --> </footer>  </body> </html>